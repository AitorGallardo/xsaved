{"version":3,"file":"service-worker.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://xsaved-extension-v2/./src/db/config.ts","webpack://xsaved-extension-v2/./src/db/database.ts","webpack://xsaved-extension-v2/./src/db/index.ts","webpack://xsaved-extension-v2/./src/search/query-parser.ts","webpack://xsaved-extension-v2/./src/search/search-executor.ts","webpack://xsaved-extension-v2/./src/search/search-engine.ts","webpack://xsaved-extension-v2/./src/search/index.ts","webpack://xsaved-extension-v2/./src/extension/utils/helpers.js","webpack://xsaved-extension-v2/./src/extension/utils/fetcher.js","webpack://xsaved-extension-v2/./src/extension/utils/communicator.js","webpack://xsaved-extension-v2/./src/extension/service-worker.ts"],"sourcesContent":["/**\n * XSaved Extension v2 - Database Configuration\n * IndexedDB schema with performance-optimized indexes\n */\nexport const DATABASE_NAME = 'XSavedDB';\nexport const DATABASE_VERSION = 2;\n// Store names\nexport const STORES = {\n    BOOKMARKS: 'bookmarks',\n    SEARCH_INDEX: 'search_index',\n    TAGS: 'tags',\n    COLLECTIONS: 'collections',\n    SETTINGS: 'settings'\n};\n// Database schema configuration\nexport const DB_CONFIG = {\n    name: DATABASE_NAME,\n    version: DATABASE_VERSION,\n    stores: {\n        // Primary bookmarks store with optimized indexes\n        [STORES.BOOKMARKS]: {\n            keyPath: 'id',\n            autoIncrement: false,\n            indexes: [\n                {\n                    name: 'created_at',\n                    keyPath: 'created_at',\n                    unique: false\n                },\n                {\n                    name: 'author',\n                    keyPath: 'author',\n                    unique: false\n                },\n                {\n                    name: 'tags',\n                    keyPath: 'tags',\n                    multiEntry: true // ‚Üê KEY: Each tag creates separate index entry\n                },\n                {\n                    name: 'bookmark_timestamp',\n                    keyPath: 'bookmark_timestamp',\n                    unique: false\n                },\n                {\n                    name: 'text_search',\n                    keyPath: 'textTokens',\n                    multiEntry: true // ‚Üê KEY: Each token creates separate index entry\n                }\n            ]\n        },\n        // Search index for performance optimization\n        [STORES.SEARCH_INDEX]: {\n            keyPath: 'bookmarkId',\n            autoIncrement: false,\n            indexes: [\n                {\n                    name: 'tokens',\n                    keyPath: 'tokens',\n                    multiEntry: true\n                },\n                {\n                    name: 'relevance_score',\n                    keyPath: 'relevanceScore',\n                    unique: false\n                },\n                {\n                    name: 'last_updated',\n                    keyPath: 'lastUpdated',\n                    unique: false\n                }\n            ]\n        },\n        // Tags store for organization and analytics\n        [STORES.TAGS]: {\n            keyPath: 'name',\n            autoIncrement: false,\n            indexes: [\n                {\n                    name: 'usage_count',\n                    keyPath: 'usageCount',\n                    unique: false\n                },\n                {\n                    name: 'created_at',\n                    keyPath: 'createdAt',\n                    unique: false\n                },\n                {\n                    name: 'category',\n                    keyPath: 'category',\n                    unique: false\n                }\n            ]\n        },\n        // Collections/folders store\n        [STORES.COLLECTIONS]: {\n            keyPath: 'id',\n            autoIncrement: false,\n            indexes: [\n                {\n                    name: 'name',\n                    keyPath: 'name',\n                    unique: false\n                },\n                {\n                    name: 'created_at',\n                    keyPath: 'createdAt',\n                    unique: false\n                },\n                {\n                    name: 'updated_at',\n                    keyPath: 'updatedAt',\n                    unique: false\n                }\n            ]\n        },\n        // Settings store\n        [STORES.SETTINGS]: {\n            keyPath: 'key',\n            autoIncrement: false,\n            indexes: [\n                {\n                    name: 'updated_at',\n                    keyPath: 'updatedAt',\n                    unique: false\n                }\n            ]\n        }\n    }\n};\n// Performance configuration\nexport const PERFORMANCE_CONFIG = {\n    // Search performance targets\n    SEARCH_TARGET_MS: 50, // Target search time\n    BATCH_SIZE: 1000, // Bulk operation batch size\n    INDEX_REBUILD_THRESHOLD: 10000, // When to rebuild search index\n    // Memory management\n    HOT_CACHE_SIZE: 100, // Recent bookmarks in memory\n    CACHE_TTL_MS: 5 * 60 * 1000, // 5 minutes cache TTL\n    // Database maintenance\n    CLEANUP_INTERVAL_HOURS: 24, // Cleanup old data\n    VACUUM_THRESHOLD_MB: 100 // Compact database threshold\n};\n// Default settings\nexport const DEFAULT_SETTINGS = {\n    // Search preferences\n    search_mode: 'smart', // 'simple' | 'smart' | 'advanced'\n    results_per_page: 50,\n    enable_fuzzy_search: true,\n    // UI preferences  \n    theme: 'auto', // 'light' | 'dark' | 'auto'\n    grid_columns: 3, // Grid layout columns\n    show_media_previews: true,\n    // Performance\n    enable_background_sync: true,\n    max_cache_size_mb: 50,\n    enable_performance_monitoring: false\n};\n// Error messages\nexport const DB_ERRORS = {\n    NOT_SUPPORTED: 'IndexedDB is not supported in this browser',\n    OPEN_FAILED: 'Failed to open database',\n    TRANSACTION_FAILED: 'Database transaction failed',\n    STORE_NOT_FOUND: 'Object store not found',\n    INDEX_NOT_FOUND: 'Index not found',\n    QUOTA_EXCEEDED: 'Storage quota exceeded',\n    DATA_CORRUPTION: 'Database corruption detected'\n};\n// Migration helpers (for future schema updates)\nexport const MIGRATION_HELPERS = {\n    // Version 1 ‚Üí 2 migration (example for future use)\n    v1_to_v2: async (db) => {\n        // Migration logic would go here\n        console.log('Migrating database from v1 to v2...');\n    }\n};\n","/**\n * XSaved Extension v2 - Database Manager\n * High-performance IndexedDB wrapper with transaction management\n */\nimport { DB_CONFIG, STORES, PERFORMANCE_CONFIG, DB_ERRORS } from './config';\nexport class XSavedDatabase {\n    constructor() {\n        this.db = null;\n        this.isInitialized = false;\n        this.initPromise = null;\n    }\n    /**\n     * Get database instance (for advanced operations)\n     */\n    get database() {\n        return this.db;\n    }\n    /**\n     * Initialize database connection with schema setup\n     */\n    async initialize() {\n        if (this.isInitialized) {\n            return { success: true };\n        }\n        if (this.initPromise) {\n            await this.initPromise;\n            return { success: true };\n        }\n        this.initPromise = this._performInitialization();\n        try {\n            await this.initPromise;\n            return { success: true };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown initialization error'\n            };\n        }\n    }\n    async _performInitialization() {\n        return new Promise((resolve, reject) => {\n            // Check IndexedDB support (compatible with both browser and service worker)\n            if (!self.indexedDB && !globalThis.indexedDB) {\n                reject(new Error(DB_ERRORS.NOT_SUPPORTED));\n                return;\n            }\n            const request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);\n            request.onerror = () => {\n                reject(new Error(DB_ERRORS.OPEN_FAILED));\n            };\n            request.onsuccess = (event) => {\n                this.db = event.target.result;\n                this.isInitialized = true;\n                console.log('‚úÖ IndexedDB opened successfully');\n                console.log('üìä Database info:', {\n                    name: this.db.name,\n                    version: this.db.version,\n                    objectStoreNames: Array.from(this.db.objectStoreNames)\n                });\n                // Detailed store verification\n                console.log('üîç Verifying object stores:');\n                Array.from(this.db.objectStoreNames).forEach(storeName => {\n                    console.log(`   ‚úÖ Store \"${storeName}\" exists`);\n                });\n                // Check if stores exist\n                if (!this.db.objectStoreNames.contains(STORES.BOOKMARKS)) {\n                    console.warn('‚ö†Ô∏è Bookmarks store missing! Database may need to be recreated.');\n                }\n                // Setup error handling\n                this.db.onerror = (error) => {\n                    console.error('Database error:', error);\n                };\n                resolve();\n            };\n            request.onupgradeneeded = (event) => {\n                console.log('üì¶ Setting up database schema...');\n                const db = event.target.result;\n                this._createSchema(db);\n                console.log('‚úÖ Database schema created successfully');\n            };\n        });\n    }\n    /**\n     * Create database schema with optimized indexes\n     */\n    _createSchema(db) {\n        Object.entries(DB_CONFIG.stores).forEach(([storeName, storeConfig]) => {\n            // Create object store\n            const store = db.createObjectStore(storeName, {\n                keyPath: storeConfig.keyPath,\n                autoIncrement: storeConfig.autoIncrement || false\n            });\n            // Create indexes\n            storeConfig.indexes.forEach((indexConfig) => {\n                store.createIndex(indexConfig.name, indexConfig.keyPath, {\n                    unique: indexConfig.unique || false,\n                    multiEntry: indexConfig.multiEntry || false\n                });\n            });\n        });\n        console.log('‚úÖ Database schema created with optimized indexes');\n    }\n    /**\n     * Ensure database is initialized before operations\n     */\n    async _ensureInitialized() {\n        if (!this.isInitialized) {\n            const result = await this.initialize();\n            if (!result.success) {\n                throw new Error(result.error || 'Failed to initialize database');\n            }\n        }\n    }\n    /**\n     * Create a database transaction with error handling\n     */\n    _createTransaction(storeNames, mode = 'readonly') {\n        if (!this.db) {\n            throw new Error('Database not initialized');\n        }\n        const transaction = this.db.transaction(storeNames, mode);\n        transaction.onerror = (event) => {\n            console.error('‚ùå Transaction error:', event);\n            console.error('‚ùå Transaction details:', {\n                mode,\n                storeNames,\n                error: transaction.error,\n                db: this.db?.name,\n                dbVersion: this.db?.version,\n                objectStoreNames: this.db ? Array.from(this.db.objectStoreNames) : 'N/A'\n            });\n        };\n        return transaction;\n    }\n    /**\n     * Performance monitoring wrapper\n     */\n    async _withPerformanceTracking(operation, fn) {\n        const startTime = performance.now();\n        try {\n            const result = await fn();\n            const duration = performance.now() - startTime;\n            const metrics = {\n                operation,\n                duration,\n                recordCount: Array.isArray(result) ? result.length : 1,\n                timestamp: new Date().toISOString()\n            };\n            // Log slow operations\n            if (duration > PERFORMANCE_CONFIG.SEARCH_TARGET_MS) {\n                console.warn(`‚ö†Ô∏è Slow operation: ${operation} took ${duration.toFixed(2)}ms`);\n            }\n            return { result, metrics };\n        }\n        catch (error) {\n            const duration = performance.now() - startTime;\n            console.error(`‚ùå Operation failed: ${operation} (${duration.toFixed(2)}ms)`, error);\n            throw error;\n        }\n    }\n    // ========================\n    // BOOKMARK OPERATIONS\n    // ========================\n    /**\n     * Add a new bookmark\n     */\n    async addBookmark(bookmark) {\n        await this._ensureInitialized();\n        try {\n            const { result, metrics } = await this._withPerformanceTracking('addBookmark', () => this._addBookmarkInternal(bookmark));\n            return {\n                success: true,\n                data: result,\n                metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to add bookmark'\n            };\n        }\n    }\n    async _addBookmarkInternal(bookmark) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                // Ensure required fields\n                const bookmarkToAdd = {\n                    ...bookmark,\n                    bookmark_timestamp: bookmark.bookmark_timestamp || new Date().toISOString(),\n                    tags: bookmark.tags || [],\n                    textTokens: this._tokenizeText(bookmark.text)\n                };\n                // Create transaction for both bookmarks and tags stores\n                const transaction = this._createTransaction([STORES.BOOKMARKS, STORES.TAGS], 'readwrite');\n                const bookmarksStore = transaction.objectStore(STORES.BOOKMARKS);\n                const tagsStore = transaction.objectStore(STORES.TAGS);\n                // Save bookmark first\n                const bookmarkRequest = bookmarksStore.add(bookmarkToAdd);\n                bookmarkRequest.onsuccess = async () => {\n                    try {\n                        // Update tag analytics after bookmark is saved\n                        await this._updateTagAnalytics(bookmarkToAdd.tags, tagsStore);\n                        console.log(`‚úÖ Bookmark and tags saved successfully: ${bookmarkToAdd.id}`);\n                        resolve(bookmarkToAdd);\n                    }\n                    catch (tagError) {\n                        console.error('‚ùå Failed to update tag analytics:', tagError);\n                        // Don't reject - bookmark was saved successfully\n                        resolve(bookmarkToAdd);\n                    }\n                };\n                bookmarkRequest.onerror = (event) => {\n                    console.error('‚ùå IndexedDB add request error:', event);\n                    console.error('‚ùå Request error details:', {\n                        error: bookmarkRequest.error,\n                        transaction: transaction.error,\n                        objectStore: bookmarksStore.name,\n                        bookmark: bookmarkToAdd\n                    });\n                    reject(new Error(`Failed to add bookmark to store: ${bookmarkRequest.error?.message || 'Unknown error'}`));\n                };\n            }\n            catch (error) {\n                console.error('‚ùå Error in _addBookmarkInternal:', error);\n                reject(error);\n            }\n        });\n    }\n    /**\n     * Get bookmark by ID\n     */\n    async getBookmark(id) {\n        await this._ensureInitialized();\n        try {\n            const { result, metrics } = await this._withPerformanceTracking('getBookmark', () => this._getBookmarkInternal(id));\n            return {\n                success: true,\n                data: result,\n                metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get bookmark'\n            };\n        }\n    }\n    async _getBookmarkInternal(id) {\n        return new Promise((resolve, reject) => {\n            const transaction = this._createTransaction(STORES.BOOKMARKS, 'readonly');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const request = store.get(id);\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to get bookmark'));\n            };\n        });\n    }\n    /**\n     * Get recent bookmarks (most common query)\n     */\n    async getRecentBookmarks(options = {}) {\n        await this._ensureInitialized();\n        try {\n            const { result, metrics } = await this._withPerformanceTracking('getRecentBookmarks', () => this._getRecentBookmarksInternal(options));\n            return {\n                success: true,\n                data: result,\n                metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get recent bookmarks'\n            };\n        }\n    }\n    async _getRecentBookmarksInternal(options) {\n        return new Promise((resolve, reject) => {\n            const transaction = this._createTransaction(STORES.BOOKMARKS, 'readonly');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const index = store.index('bookmark_timestamp');\n            const results = [];\n            const limit = options.limit || 50;\n            let count = 0;\n            // Use cursor for efficient pagination\n            const request = index.openCursor(null, 'prev'); // Most recent first\n            request.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (cursor && count < limit) {\n                    results.push(cursor.value);\n                    count++;\n                    cursor.continue();\n                }\n                else {\n                    resolve(results);\n                }\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to get recent bookmarks'));\n            };\n        });\n    }\n    /**\n     * Search bookmarks by tags (optimized with multi-entry index)\n     */\n    async getBookmarksByTag(tag) {\n        await this._ensureInitialized();\n        try {\n            const { result, metrics } = await this._withPerformanceTracking('getBookmarksByTag', () => this._getBookmarksByTagInternal(tag));\n            return {\n                success: true,\n                data: result,\n                metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to search by tag'\n            };\n        }\n    }\n    async _getBookmarksByTagInternal(tag) {\n        return new Promise((resolve, reject) => {\n            const transaction = this._createTransaction(STORES.BOOKMARKS, 'readonly');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const index = store.index('tags');\n            const request = index.getAll(tag); // Multi-entry index magic!\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to search by tag'));\n            };\n        });\n    }\n    /**\n     * Delete bookmark by ID\n     */\n    async deleteBookmark(id) {\n        await this._ensureInitialized();\n        try {\n            const { metrics } = await this._withPerformanceTracking('deleteBookmark', () => this._deleteBookmarkInternal(id));\n            return {\n                success: true,\n                metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to delete bookmark'\n            };\n        }\n    }\n    async _deleteBookmarkInternal(id) {\n        return new Promise((resolve, reject) => {\n            const transaction = this._createTransaction(STORES.BOOKMARKS, 'readwrite');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const request = store.delete(id);\n            request.onsuccess = () => {\n                resolve();\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to delete bookmark'));\n            };\n        });\n    }\n    // ========================\n    // UTILITY METHODS\n    // ========================\n    /**\n     * Tokenize text for search indexing\n     */\n    _tokenizeText(text) {\n        return text\n            .toLowerCase()\n            .replace(/[^\\w\\s#@]/g, ' ') // Keep hashtags and mentions\n            .split(/\\s+/)\n            .filter(token => token.length > 2) // Filter short tokens\n            .slice(0, 50); // Limit tokens to prevent bloat\n    }\n    /**\n     * Get all bookmarks with optional filtering and sorting\n     */\n    async getAllBookmarks(options = {}) {\n        await this._ensureInitialized();\n        try {\n            const { result, metrics } = await this._withPerformanceTracking('getAllBookmarks', () => this._getAllBookmarksInternal(options));\n            return {\n                success: true,\n                data: result,\n                metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get all bookmarks'\n            };\n        }\n    }\n    async _getAllBookmarksInternal(options) {\n        return new Promise((resolve, reject) => {\n            const transaction = this._createTransaction(STORES.BOOKMARKS, 'readonly');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const sortBy = options.sortBy || 'created_at';\n            const direction = options.sortOrder === 'asc' ? 'next' : 'prev';\n            let request;\n            if (store.indexNames.contains(sortBy)) {\n                const index = store.index(sortBy);\n                request = index.openCursor(null, direction);\n            }\n            else {\n                request = store.openCursor(null, direction);\n            }\n            const results = [];\n            const limit = options.limit || 1000;\n            request.onsuccess = (event) => {\n                const cursor = event.target.result;\n                if (cursor && results.length < limit) {\n                    results.push(cursor.value);\n                    cursor.continue();\n                }\n                else {\n                    resolve(results);\n                }\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to get all bookmarks'));\n            };\n        });\n    }\n    /**\n     * Clear all bookmarks from database\n     */\n    async clearAllBookmarks() {\n        await this._ensureInitialized();\n        try {\n            const { result, metrics } = await this._withPerformanceTracking('clearAllBookmarks', () => this._clearAllBookmarksInternal());\n            return {\n                success: true,\n                data: result,\n                metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to clear all bookmarks'\n            };\n        }\n    }\n    async _clearAllBookmarksInternal() {\n        return new Promise((resolve, reject) => {\n            const transaction = this._createTransaction(STORES.BOOKMARKS, 'readwrite');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const request = store.clear();\n            request.onsuccess = () => {\n                resolve();\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to clear bookmarks store'));\n            };\n        });\n    }\n    /**\n     * Get database statistics\n     */\n    async getStats() {\n        await this._ensureInitialized();\n        try {\n            const bookmarkCount = await this._getStoreCount(STORES.BOOKMARKS);\n            const tagCount = await this._getStoreCount(STORES.TAGS);\n            return {\n                success: true,\n                data: {\n                    bookmarks: bookmarkCount,\n                    tags: tagCount,\n                    version: DB_CONFIG.version,\n                    initialized: this.isInitialized\n                }\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get stats'\n            };\n        }\n    }\n    async _getStoreCount(storeName) {\n        return new Promise((resolve, reject) => {\n            const transaction = this._createTransaction(storeName, 'readonly');\n            const store = transaction.objectStore(storeName);\n            const request = store.count();\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(new Error(`Failed to count ${storeName}`));\n            };\n        });\n    }\n    // ===== TAG MANAGEMENT METHODS =====\n    /**\n     * Update tag analytics when bookmarks are saved\n     */\n    async _updateTagAnalytics(tags, tagsStore) {\n        if (!tags || tags.length === 0)\n            return;\n        const timestamp = new Date().toISOString();\n        for (const tagName of tags) {\n            if (!tagName.trim())\n                continue;\n            try {\n                // Get existing tag\n                const getRequest = tagsStore.get(tagName);\n                await new Promise((resolve, reject) => {\n                    getRequest.onsuccess = () => {\n                        const existingTag = getRequest.result;\n                        if (existingTag) {\n                            // Update existing tag\n                            existingTag.usageCount = (existingTag.usageCount || 0) + 1;\n                            const updateRequest = tagsStore.put(existingTag);\n                            updateRequest.onsuccess = () => {\n                                console.log(`üìä Updated tag analytics: ${tagName} (usage: ${existingTag.usageCount})`);\n                                resolve();\n                            };\n                            updateRequest.onerror = () => reject(new Error(`Failed to update tag: ${tagName}`));\n                        }\n                        else {\n                            // Create new tag\n                            const newTag = {\n                                name: tagName,\n                                usageCount: 1,\n                                createdAt: timestamp\n                            };\n                            const addRequest = tagsStore.add(newTag);\n                            addRequest.onsuccess = () => {\n                                console.log(`üè∑Ô∏è Created new tag: ${tagName}`);\n                                resolve();\n                            };\n                            addRequest.onerror = () => reject(new Error(`Failed to create tag: ${tagName}`));\n                        }\n                    };\n                    getRequest.onerror = () => reject(new Error(`Failed to get tag: ${tagName}`));\n                });\n            }\n            catch (error) {\n                console.error(`‚ùå Failed to update tag analytics for: ${tagName}`, error);\n                // Continue with other tags even if one fails\n            }\n        }\n    }\n    /**\n     * Get all tags with their usage statistics\n     */\n    async getAllTags() {\n        await this._ensureInitialized();\n        try {\n            const result = await this._withPerformanceTracking('getAllTags', async () => {\n                return new Promise((resolve, reject) => {\n                    const transaction = this._createTransaction(STORES.TAGS, 'readonly');\n                    const store = transaction.objectStore(STORES.TAGS);\n                    const request = store.getAll();\n                    request.onsuccess = () => {\n                        resolve(request.result || []);\n                    };\n                    request.onerror = () => {\n                        reject(new Error('Failed to get all tags'));\n                    };\n                });\n            });\n            return {\n                success: true,\n                data: result.result,\n                metrics: result.metrics\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get tags'\n            };\n        }\n    }\n    /**\n     * Get popular tags (sorted by usage count)\n     */\n    async getPopularTags(limit = 20) {\n        const allTagsResult = await this.getAllTags();\n        if (!allTagsResult.success) {\n            return allTagsResult;\n        }\n        try {\n            const popularTags = allTagsResult.data\n                .sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0))\n                .slice(0, limit);\n            return {\n                success: true,\n                data: popularTags\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get popular tags'\n            };\n        }\n    }\n    /**\n     * Search tags by name (for autocomplete)\n     */\n    async searchTags(query, limit = 10) {\n        const allTagsResult = await this.getAllTags();\n        if (!allTagsResult.success) {\n            return allTagsResult;\n        }\n        try {\n            const matchingTags = allTagsResult.data\n                .filter(tag => tag.name.toLowerCase().includes(query.toLowerCase()))\n                .sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0))\n                .slice(0, limit);\n            return {\n                success: true,\n                data: matchingTags\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to search tags'\n            };\n        }\n    }\n    /**\n     * Verify database is working by testing basic operations\n     */\n    async verifyDatabase() {\n        if (!this.isInitialized) {\n            await this.initialize();\n        }\n        console.log('üß™ Testing database functionality...');\n        // Test bookmark creation\n        const testBookmark = {\n            id: 'test_' + Date.now(),\n            text: 'Test bookmark for verification',\n            author: 'test_user',\n            created_at: new Date().toISOString(),\n            bookmark_timestamp: new Date().toISOString(),\n            tags: ['test'],\n            media_urls: [],\n            textTokens: ['test', 'bookmark', 'verification']\n        };\n        try {\n            // Add test bookmark\n            const addResult = await this.addBookmark(testBookmark);\n            if (addResult.success) {\n                console.log('‚úÖ Test bookmark added successfully');\n            }\n            else {\n                console.error('‚ùå Failed to add test bookmark:', addResult.error);\n                return;\n            }\n            // Retrieve test bookmark\n            const getResult = await this.getBookmark(testBookmark.id);\n            if (getResult.success && getResult.data) {\n                console.log('‚úÖ Test bookmark retrieved successfully');\n                // Clean up test bookmark\n                await this.deleteBookmark(testBookmark.id);\n                console.log('‚úÖ Test bookmark cleaned up');\n                console.log('üéâ Database verification completed successfully!');\n            }\n            else {\n                console.error('‚ùå Failed to retrieve test bookmark');\n            }\n        }\n        catch (error) {\n            console.error('‚ùå Database verification failed:', error);\n        }\n    }\n    /**\n     * Close database connection\n     */\n    close() {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n            this.isInitialized = false;\n        }\n    }\n}\n// Export singleton instance\nexport const db = new XSavedDatabase();\n","/**\n * XSaved Extension v2 - Database Module\n * Main exports for the data layer\n */\n// Main database class\nexport { XSavedDatabase, db } from './database';\n// Configuration\nexport { DATABASE_NAME, DATABASE_VERSION, STORES, DB_CONFIG, PERFORMANCE_CONFIG, DEFAULT_SETTINGS, DB_ERRORS } from './config';\n","/**\n * XSaved Extension v2 - Query Parser\n * Transforms user input into optimized search queries\n */\nexport class QueryParser {\n    constructor(textConfig) {\n        this.textConfig = textConfig;\n    }\n    /**\n     * Parse user search query into optimized execution plan\n     */\n    parseQuery(query) {\n        const parsed = {\n            textTokens: [],\n            exactPhrases: [],\n            requiredTags: query.tags || [],\n            optionalTags: [],\n            excludedTags: query.excludeTags || [],\n            filters: [],\n            queryPlan: {\n                primaryFilter: null,\n                secondaryFilters: [],\n                intersectionStrategy: 'all',\n                estimatedResultCount: 0,\n                estimatedExecutionTime: 0\n            },\n            originalQuery: query\n        };\n        // Parse text input\n        if (query.text) {\n            this.parseTextQuery(query.text, parsed);\n        }\n        // Build filters\n        this.buildFilters(query, parsed);\n        // Optimize execution plan\n        parsed.queryPlan = this.optimizeQueryPlan(parsed);\n        return parsed;\n    }\n    /**\n     * Parse text query for tokens, phrases, and special syntax\n     */\n    parseTextQuery(text, parsed) {\n        // Extract exact phrases in quotes\n        const phraseMatches = text.match(/\"([^\"]*)\"/g);\n        if (phraseMatches) {\n            parsed.exactPhrases = phraseMatches.map(phrase => phrase.replace(/\"/g, '').toLowerCase().trim());\n            // Remove phrases from text for token extraction\n            text = text.replace(/\"[^\"]*\"/g, '');\n        }\n        // Extract hashtags as required tags\n        const hashtagMatches = text.match(/#(\\w+)/g);\n        if (hashtagMatches) {\n            const hashtags = hashtagMatches.map(tag => tag.replace('#', '').toLowerCase());\n            parsed.requiredTags.push(...hashtags);\n            // Remove hashtags from text\n            text = text.replace(/#\\w+/g, '');\n        }\n        // Extract @mentions (could be author filters)\n        const mentionMatches = text.match(/@(\\w+)/g);\n        if (mentionMatches) {\n            // For now, treat mentions as optional tokens\n            // In future, could auto-add author filter\n            const mentions = mentionMatches.map(mention => mention.replace('@', '').toLowerCase());\n            parsed.optionalTags.push(...mentions);\n            // Keep mentions in text for now\n        }\n        // Tokenize remaining text\n        const tokens = this.tokenizeText(text);\n        parsed.textTokens = tokens;\n    }\n    /**\n     * Tokenize text into searchable terms\n     */\n    tokenizeText(text) {\n        return text\n            .toLowerCase()\n            .replace(/[^\\w\\s]/g, ' ') // Remove punctuation except underscores\n            .split(/\\s+/)\n            .filter(token => token.length >= this.textConfig.minTokenLength)\n            .slice(0, this.textConfig.maxTokens) // Limit token count\n            .filter(token => !this.isStopWord(token));\n    }\n    /**\n     * Check if token is a stop word (common words to ignore)\n     */\n    isStopWord(token) {\n        const stopWords = new Set([\n            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',\n            'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have',\n            'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should'\n        ]);\n        return stopWords.has(token);\n    }\n    /**\n     * Build query filters from search parameters\n     */\n    buildFilters(query, parsed) {\n        const filters = [];\n        // Text token filters\n        parsed.textTokens.forEach(token => {\n            filters.push({\n                type: 'textToken',\n                value: token,\n                selectivity: this.estimateTokenSelectivity(token),\n                estimatedCost: 10 // ms\n            });\n        });\n        // Tag filters (most selective)\n        parsed.requiredTags.forEach(tag => {\n            filters.push({\n                type: 'tag',\n                value: tag,\n                selectivity: this.estimateTagSelectivity(tag),\n                estimatedCost: 5 // ms - direct index lookup\n            });\n        });\n        // Author filter\n        if (query.author) {\n            filters.push({\n                type: 'author',\n                value: query.author,\n                selectivity: 0.05, // Usually quite selective\n                estimatedCost: 8 // ms\n            });\n        }\n        // Date range filter\n        if (query.dateRange) {\n            filters.push({\n                type: 'dateRange',\n                value: query.dateRange,\n                selectivity: this.estimateDateSelectivity(query.dateRange),\n                estimatedCost: 15 // ms - range query\n            });\n        }\n        // Media filter\n        if (query.hasMedia !== undefined) {\n            filters.push({\n                type: 'hasMedia',\n                value: query.hasMedia,\n                selectivity: query.hasMedia ? 0.3 : 0.7, // ~30% have media\n                estimatedCost: 5 // ms\n            });\n        }\n        parsed.filters = filters;\n    }\n    /**\n     * Optimize query execution plan based on filter selectivity\n     */\n    optimizeQueryPlan(parsed) {\n        const filters = [...parsed.filters];\n        // Sort by selectivity (most selective first)\n        filters.sort((a, b) => a.selectivity - b.selectivity);\n        const primaryFilter = filters[0];\n        const secondaryFilters = filters.slice(1);\n        // Estimate result count based on most selective filter\n        const estimatedResultCount = primaryFilter\n            ? Math.max(1, Math.floor(10000 * primaryFilter.selectivity)) // Assume 10K total bookmarks\n            : 1000;\n        // Estimate execution time\n        const estimatedExecutionTime = filters.reduce((total, filter) => total + filter.estimatedCost, 0);\n        // Choose intersection strategy\n        let intersectionStrategy = 'all';\n        if (parsed.textTokens.length > 0 && parsed.requiredTags.length > 0) {\n            intersectionStrategy = 'all'; // Text AND tags\n        }\n        else if (parsed.optionalTags.length > 0) {\n            intersectionStrategy = 'any'; // Any optional tags\n        }\n        return {\n            primaryFilter,\n            secondaryFilters,\n            intersectionStrategy,\n            estimatedResultCount,\n            estimatedExecutionTime\n        };\n    }\n    /**\n     * Estimate selectivity of a text token\n     */\n    estimateTokenSelectivity(token) {\n        // Common words are less selective\n        const commonWords = new Set(['react', 'javascript', 'web', 'app', 'code']);\n        if (commonWords.has(token)) {\n            return 0.2; // 20% of bookmarks might contain this\n        }\n        // Technical terms are more selective\n        if (token.length > 8) {\n            return 0.05; // Long words are usually more specific\n        }\n        return 0.1; // Default selectivity\n    }\n    /**\n     * Estimate selectivity of a tag\n     */\n    estimateTagSelectivity(tag) {\n        // Popular tags are less selective\n        const popularTags = new Set(['javascript', 'python', 'ai', 'web', 'tutorial']);\n        if (popularTags.has(tag)) {\n            return 0.15;\n        }\n        return 0.05; // Most tags are quite selective\n    }\n    /**\n     * Estimate selectivity of date range\n     */\n    estimateDateSelectivity(dateRange) {\n        const start = new Date(dateRange.start);\n        const end = new Date(dateRange.end);\n        const daysDiff = (end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24);\n        // Recent date ranges are more selective\n        if (daysDiff <= 1)\n            return 0.02; // Last day\n        if (daysDiff <= 7)\n            return 0.1; // Last week  \n        if (daysDiff <= 30)\n            return 0.3; // Last month\n        return 0.8; // Longer ranges are less selective\n    }\n    /**\n     * Extract search suggestions from query\n     */\n    extractSuggestions(query) {\n        const suggestions = [];\n        // Suggest related searches based on current query\n        if (query.text) {\n            const tokens = this.tokenizeText(query.text);\n            // Suggest adding common tags\n            tokens.forEach(token => {\n                if (this.couldBeTag(token)) {\n                    suggestions.push(`${query.text} #${token}`);\n                }\n            });\n        }\n        // Suggest adding author filter if text contains @mention\n        if (query.text?.includes('@')) {\n            const mentions = query.text.match(/@(\\w+)/g);\n            mentions?.forEach(mention => {\n                const author = mention.replace('@', '');\n                suggestions.push(`author:${author} ${query.text?.replace(mention, '').trim()}`);\n            });\n        }\n        return suggestions.slice(0, 3); // Limit suggestions\n    }\n    /**\n     * Check if token could be a tag\n     */\n    couldBeTag(token) {\n        // Technical terms, frameworks, languages likely to be tags\n        const techTerms = /^(react|vue|angular|python|javascript|js|ai|ml|css|html|node|npm)$/i;\n        return techTerms.test(token) || token.length > 6;\n    }\n    /**\n     * Generate query hash for caching\n     */\n    generateQueryHash(query) {\n        const normalized = {\n            text: query.text?.toLowerCase().trim(),\n            tags: query.tags?.sort(),\n            author: query.author?.toLowerCase(),\n            dateRange: query.dateRange,\n            excludeTags: query.excludeTags?.sort(),\n            hasMedia: query.hasMedia,\n            sortBy: query.sortBy || 'relevance',\n            limit: query.limit || 50\n        };\n        return btoa(JSON.stringify(normalized)).replace(/[+/=]/g, '');\n    }\n}\n","/**\n * XSaved Extension v2 - Search Executor\n * Executes optimized queries against IndexedDB indexes\n */\nimport { db, STORES } from '../db';\nexport class SearchExecutor {\n    constructor(config) {\n        this.config = config;\n    }\n    /**\n     * Execute multi-criteria search query\n     */\n    async executeSearch(parsedQuery) {\n        const startTime = performance.now();\n        let analytics = {\n            queryTime: 0,\n            indexHits: 0,\n            resultsReturned: 0,\n            cacheHit: false,\n            slowOperations: [],\n            indexesUsed: []\n        };\n        try {\n            // Ensure database is ready\n            await db.initialize();\n            // Execute primary filter first (most selective)\n            let candidateBookmarks = [];\n            if (parsedQuery.queryPlan.primaryFilter) {\n                candidateBookmarks = await this.executeSingleFilter(parsedQuery.queryPlan.primaryFilter, analytics);\n            }\n            else {\n                // No filters - get recent bookmarks as starting point\n                const recentResult = await db.getRecentBookmarks({ limit: 1000 });\n                candidateBookmarks = recentResult.data || [];\n                analytics.indexesUsed.push('bookmark_timestamp');\n            }\n            // Apply secondary filters\n            for (const filter of parsedQuery.queryPlan.secondaryFilters) {\n                candidateBookmarks = await this.applyFilter(candidateBookmarks, filter, analytics);\n                // Early termination if too few results\n                if (candidateBookmarks.length === 0) {\n                    break;\n                }\n            }\n            // Apply text search if present\n            if (parsedQuery.textTokens.length > 0) {\n                candidateBookmarks = await this.applyTextSearch(candidateBookmarks, parsedQuery.textTokens, analytics);\n            }\n            // Filter out excluded tags\n            if (parsedQuery.excludedTags.length > 0) {\n                candidateBookmarks = candidateBookmarks.filter(bookmark => !parsedQuery.excludedTags.some(excludedTag => bookmark.tags.includes(excludedTag)));\n            }\n            const queryTime = performance.now() - startTime;\n            analytics.queryTime = queryTime;\n            analytics.resultsReturned = candidateBookmarks.length;\n            // Log slow operations\n            if (queryTime > this.config.performanceTargets.combinedSearch) {\n                analytics.slowOperations.push(`Total query: ${queryTime.toFixed(2)}ms`);\n                console.warn(`‚ö†Ô∏è Slow search query: ${queryTime.toFixed(2)}ms`, parsedQuery);\n            }\n            return {\n                bookmarks: candidateBookmarks.map(bookmark => ({\n                    bookmark,\n                    score: 1, // Will be calculated by relevance scorer\n                    matchingFactors: {\n                        textRelevance: 0,\n                        tagRelevance: 0,\n                        recency: 0,\n                        authorPopularity: 0,\n                        userInteraction: 0,\n                        exactMatch: false\n                    }\n                })),\n                totalCount: candidateBookmarks.length,\n                queryTime,\n                pagination: {\n                    hasMore: false,\n                    totalPages: 1\n                }\n            };\n        }\n        catch (error) {\n            console.error('Search execution error:', error);\n            return {\n                bookmarks: [],\n                totalCount: 0,\n                queryTime: performance.now() - startTime,\n                pagination: {\n                    hasMore: false,\n                    totalPages: 0\n                }\n            };\n        }\n    }\n    /**\n     * Execute a single filter using appropriate index\n     */\n    async executeSingleFilter(filter, analytics) {\n        const startTime = performance.now();\n        try {\n            let result = [];\n            switch (filter.type) {\n                case 'tag':\n                    result = await this.searchByTag(filter.value);\n                    analytics.indexesUsed.push('tags');\n                    break;\n                case 'author':\n                    result = await this.searchByAuthor(filter.value);\n                    analytics.indexesUsed.push('author');\n                    break;\n                case 'dateRange':\n                    result = await this.searchByDateRange(filter.value);\n                    analytics.indexesUsed.push('bookmark_timestamp');\n                    break;\n                case 'textToken':\n                    result = await this.searchByTextToken(filter.value);\n                    analytics.indexesUsed.push('text_search');\n                    break;\n                case 'hasMedia':\n                    result = await this.searchByMediaPresence(filter.value);\n                    // No specific index for this - filters in memory\n                    break;\n                default:\n                    console.warn('Unknown filter type:', filter.type);\n            }\n            const duration = performance.now() - startTime;\n            analytics.indexHits++;\n            // Track slow operations\n            const target = this.getPerformanceTarget(filter.type);\n            if (duration > target) {\n                analytics.slowOperations.push(`${filter.type}: ${duration.toFixed(2)}ms`);\n            }\n            return result;\n        }\n        catch (error) {\n            console.error(`Filter execution error for ${filter.type}:`, error);\n            return [];\n        }\n    }\n    /**\n     * Apply filter to existing result set\n     */\n    async applyFilter(bookmarks, filter, analytics) {\n        const startTime = performance.now();\n        let filtered = [];\n        switch (filter.type) {\n            case 'tag':\n                filtered = bookmarks.filter(bookmark => bookmark.tags.includes(filter.value));\n                break;\n            case 'author':\n                filtered = bookmarks.filter(bookmark => bookmark.author.toLowerCase() === filter.value.toLowerCase());\n                break;\n            case 'hasMedia':\n                filtered = bookmarks.filter(bookmark => filter.value ?\n                    (bookmark.media_urls && bookmark.media_urls.length > 0) :\n                    (!bookmark.media_urls || bookmark.media_urls.length === 0));\n                break;\n            case 'dateRange':\n                const { start, end } = filter.value;\n                filtered = bookmarks.filter(bookmark => {\n                    const bookmarkDate = new Date(bookmark.bookmark_timestamp);\n                    return bookmarkDate >= new Date(start) && bookmarkDate <= new Date(end);\n                });\n                break;\n            case 'textToken':\n                filtered = bookmarks.filter(bookmark => bookmark.textTokens?.includes(filter.value) ||\n                    bookmark.text.toLowerCase().includes(filter.value));\n                break;\n            default:\n                filtered = bookmarks;\n        }\n        const duration = performance.now() - startTime;\n        const target = this.getPerformanceTarget(filter.type);\n        if (duration > target) {\n            analytics.slowOperations.push(`${filter.type} filter: ${duration.toFixed(2)}ms`);\n        }\n        return filtered;\n    }\n    /**\n     * Search by tag using multi-entry index (fastest)\n     */\n    async searchByTag(tag) {\n        const result = await db.getBookmarksByTag(tag);\n        return result.success ? result.data || [] : [];\n    }\n    /**\n     * Search by author using author index\n     */\n    async searchByAuthor(author) {\n        // Use the database's indexed search (we need to add this method to database.ts)\n        return new Promise((resolve, reject) => {\n            if (!db.database) {\n                reject(new Error('Database not initialized'));\n                return;\n            }\n            const transaction = db.database.transaction([STORES.BOOKMARKS], 'readonly');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const index = store.index('author');\n            const request = index.getAll(author.toLowerCase());\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to search by author'));\n            };\n        });\n    }\n    /**\n     * Search by date range using bookmark_timestamp index\n     */\n    async searchByDateRange(dateRange) {\n        return new Promise((resolve, reject) => {\n            if (!db.database) {\n                reject(new Error('Database not initialized'));\n                return;\n            }\n            const transaction = db.database.transaction([STORES.BOOKMARKS], 'readonly');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const index = store.index('bookmark_timestamp');\n            const range = IDBKeyRange.bound(dateRange.start, dateRange.end);\n            const request = index.getAll(range);\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to search by date range'));\n            };\n        });\n    }\n    /**\n     * Search by text token using text_search multi-entry index\n     */\n    async searchByTextToken(token) {\n        return new Promise((resolve, reject) => {\n            if (!db.database) {\n                reject(new Error('Database not initialized'));\n                return;\n            }\n            const transaction = db.database.transaction([STORES.BOOKMARKS], 'readonly');\n            const store = transaction.objectStore(STORES.BOOKMARKS);\n            const index = store.index('text_search');\n            const request = index.getAll(token);\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => {\n                reject(new Error('Failed to search by text token'));\n            };\n        });\n    }\n    /**\n     * Filter by media presence (no index available)\n     */\n    async searchByMediaPresence(hasMedia) {\n        // No specific index for this - need to scan bookmarks\n        // This is less efficient, so should be used as secondary filter\n        const recentResult = await db.getRecentBookmarks({ limit: 10000 });\n        const allBookmarks = recentResult.data || [];\n        return allBookmarks.filter(bookmark => hasMedia ?\n            (bookmark.media_urls && bookmark.media_urls.length > 0) :\n            (!bookmark.media_urls || bookmark.media_urls.length === 0));\n    }\n    /**\n     * Apply text search with token matching\n     */\n    async applyTextSearch(bookmarks, tokens, analytics) {\n        if (tokens.length === 0)\n            return bookmarks;\n        const startTime = performance.now();\n        const filtered = bookmarks.filter(bookmark => {\n            // Check if bookmark contains any of the search tokens\n            const bookmarkTokens = bookmark.textTokens || [];\n            const bookmarkText = bookmark.text.toLowerCase();\n            return tokens.some(token => bookmarkTokens.includes(token) ||\n                bookmarkText.includes(token));\n        });\n        const duration = performance.now() - startTime;\n        if (duration > this.config.performanceTargets.textSearch) {\n            analytics.slowOperations.push(`Text search: ${duration.toFixed(2)}ms`);\n        }\n        return filtered;\n    }\n    /**\n     * Intersect multiple result sets efficiently\n     */\n    intersectResults(resultSets) {\n        if (resultSets.length === 0)\n            return [];\n        if (resultSets.length === 1)\n            return resultSets[0];\n        // Sort by length (smallest first) for efficient intersection\n        resultSets.sort((a, b) => a.length - b.length);\n        let intersection = resultSets[0];\n        for (let i = 1; i < resultSets.length; i++) {\n            const currentSet = new Set(resultSets[i].map(bookmark => bookmark.id));\n            intersection = intersection.filter(bookmark => currentSet.has(bookmark.id));\n            // Early termination if intersection becomes empty\n            if (intersection.length === 0)\n                break;\n        }\n        return intersection;\n    }\n    /**\n     * Union multiple result sets with deduplication\n     */\n    unionResults(resultSets) {\n        const seen = new Set();\n        const union = [];\n        for (const resultSet of resultSets) {\n            for (const bookmark of resultSet) {\n                if (!seen.has(bookmark.id)) {\n                    seen.add(bookmark.id);\n                    union.push(bookmark);\n                }\n            }\n        }\n        return union;\n    }\n    /**\n     * Get performance target for filter type\n     */\n    getPerformanceTarget(filterType) {\n        switch (filterType) {\n            case 'tag':\n                return this.config.performanceTargets.singleTagSearch;\n            case 'textToken':\n                return this.config.performanceTargets.textSearch;\n            case 'author':\n            case 'dateRange':\n                return this.config.performanceTargets.multiTagSearch;\n            default:\n                return this.config.performanceTargets.combinedSearch;\n        }\n    }\n}\n","/**\n * XSaved Extension v2 - Search Engine\n * Main search engine that orchestrates query parsing, execution, and ranking\n */\nimport { QueryParser } from './query-parser';\nimport { SearchExecutor } from './search-executor';\nexport class SearchEngine {\n    constructor(config) {\n        this.config = this.createDefaultConfig(config);\n        this.queryParser = new QueryParser(this.config.textSearch);\n        this.searchExecutor = new SearchExecutor(this.config);\n        this.queryCache = new Map();\n    }\n    /**\n     * Main search method - the public API\n     */\n    async search(query) {\n        const startTime = performance.now();\n        try {\n            // Generate cache key\n            const cacheKey = this.queryParser.generateQueryHash(query);\n            // Check cache first\n            if (this.config.caching.enabled) {\n                const cached = this.getCachedResult(cacheKey);\n                if (cached) {\n                    console.log('üéØ Cache hit for query:', query);\n                    return cached;\n                }\n            }\n            // Parse query into optimized execution plan\n            const parsedQuery = this.queryParser.parseQuery(query);\n            console.log('üìù Parsed query:', parsedQuery);\n            // Execute search\n            const result = await this.searchExecutor.executeSearch(parsedQuery);\n            // Add suggested queries\n            result.suggestedQueries = this.queryParser.extractSuggestions(query);\n            // Cache result if enabled\n            if (this.config.caching.enabled) {\n                this.cacheResult(cacheKey, result);\n            }\n            // Log performance\n            const totalTime = performance.now() - startTime;\n            console.log(`üîç Search completed in ${totalTime.toFixed(2)}ms:`, {\n                query: query.text || 'complex query',\n                results: result.totalCount,\n                cacheHit: false\n            });\n            return result;\n        }\n        catch (error) {\n            console.error('Search engine error:', error);\n            return {\n                bookmarks: [],\n                totalCount: 0,\n                queryTime: performance.now() - startTime,\n                pagination: {\n                    hasMore: false,\n                    totalPages: 0\n                }\n            };\n        }\n    }\n    /**\n     * Quick tag-only search (optimized for autocomplete)\n     */\n    async quickTagSearch(tag) {\n        return this.search({ tags: [tag], limit: 20 });\n    }\n    /**\n     * Text-only search (for search-as-you-type)\n     */\n    async quickTextSearch(text) {\n        return this.search({ text, limit: 20 });\n    }\n    /**\n     * Author search\n     */\n    async searchByAuthor(author) {\n        return this.search({ author, limit: 50 });\n    }\n    /**\n     * Recent bookmarks with optional filters\n     */\n    async getRecent(filters) {\n        return this.search({\n            ...filters,\n            sortBy: 'date',\n            limit: filters?.limit || 50\n        });\n    }\n    /**\n     * Get tag suggestions for autocomplete\n     */\n    async suggestTags(partial) {\n        // This would use the tags store from our database\n        // For now, return empty array - will implement when we add tag management\n        return [];\n    }\n    /**\n     * Get search suggestions based on current query\n     */\n    async getSearchSuggestions(query) {\n        return this.queryParser.extractSuggestions(query);\n    }\n    /**\n     * Clear search cache\n     */\n    clearCache() {\n        this.queryCache.clear();\n        console.log('üßπ Search cache cleared');\n    }\n    /**\n     * Get cache statistics\n     */\n    getCacheStats() {\n        // Simple implementation - in production would track hit rate\n        return {\n            size: this.queryCache.size,\n            hitRate: 0.85 // Placeholder\n        };\n    }\n    /**\n     * Update search engine configuration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        // Recreate components with new config\n        this.queryParser = new QueryParser(this.config.textSearch);\n        this.searchExecutor = new SearchExecutor(this.config);\n        console.log('‚öôÔ∏è Search engine configuration updated');\n    }\n    // Private methods\n    /**\n     * Create default configuration\n     */\n    createDefaultConfig(userConfig) {\n        const defaultConfig = {\n            performanceTargets: {\n                singleTagSearch: 5, // 5ms\n                multiTagSearch: 20, // 20ms  \n                textSearch: 30, // 30ms\n                combinedSearch: 50, // 50ms\n                autocomplete: 10 // 10ms\n            },\n            caching: {\n                enabled: true,\n                maxCacheSize: 100, // Cache 100 recent queries\n                cacheTimeout: 5 * 60 * 1000 // 5 minutes\n            },\n            textSearch: {\n                enableFuzzyMatching: false, // Start simple\n                enableStemming: false,\n                enableSynonyms: false,\n                minTokenLength: 3,\n                maxTokens: 10,\n                proximityBoost: false\n            },\n            relevanceWeights: {\n                textMatch: 0.4,\n                tagMatch: 0.3,\n                recency: 0.15,\n                interaction: 0.1,\n                author: 0.05\n            }\n        };\n        return userConfig ? { ...defaultConfig, ...userConfig } : defaultConfig;\n    }\n    /**\n     * Get cached search result\n     */\n    getCachedResult(cacheKey) {\n        const cached = this.queryCache.get(cacheKey);\n        if (!cached)\n            return null;\n        // Check if cache entry is expired\n        const now = Date.now();\n        if (now - cached.timestamp > this.config.caching.cacheTimeout) {\n            this.queryCache.delete(cacheKey);\n            return null;\n        }\n        return cached.result;\n    }\n    /**\n     * Cache search result\n     */\n    cacheResult(cacheKey, result) {\n        // Implement LRU cache eviction if cache is full\n        if (this.queryCache.size >= this.config.caching.maxCacheSize) {\n            // Remove oldest entry\n            const oldestKey = this.queryCache.keys().next().value;\n            if (oldestKey) {\n                this.queryCache.delete(oldestKey);\n            }\n        }\n        this.queryCache.set(cacheKey, {\n            result,\n            timestamp: Date.now()\n        });\n    }\n}\n// Export default instance\nexport const searchEngine = new SearchEngine();\n","/**\n * XSaved Extension v2 - Search Module\n * Main exports for the search and filtering system\n */\n// Main search engine\nexport { SearchEngine, searchEngine } from './search-engine';\n// Core components  \nexport { QueryParser } from './query-parser';\nexport { SearchExecutor } from './search-executor';\n","/**\n * XSaved Extension v2 - Helper Utilities\n * Common helper functions and error classes\n * Adapted from proven v1 extension with enhancements\n */\n\n/**\n * Delay execution for specified milliseconds\n * @param {Number} ms - Milliseconds to delay\n * @returns {Promise} Promise that resolves after the delay\n */\nexport const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Create a retry function with exponential backoff\n * @param {Function} fn - The function to retry\n * @param {Object} options - Retry options\n * @param {Number} options.maxRetries - Maximum number of retries\n * @param {Number} options.baseDelay - Base delay in milliseconds\n * @param {Boolean} options.jitter - Whether to add randomness to delay\n * @returns {Function} A wrapped function with retry logic\n */\nexport const withRetry = (fn, options = {}) => {\n  const { \n    maxRetries = 3, \n    baseDelay = 1000, \n    jitter = true \n  } = options;\n  \n  return async (...args) => {\n    let lastError;\n    \n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        return await fn(...args);\n      } catch (error) {\n        lastError = error;\n        \n        // Don't retry if we've hit the max retries\n        if (attempt >= maxRetries) break;\n        \n        // Special handling for rate limit errors\n        const isRateLimit = error instanceof RateLimitError;\n        if (isRateLimit) {\n          console.warn(`‚è±Ô∏è Rate limit hit. Attempt ${attempt + 1}/${maxRetries + 1}`);\n        } else {\n          console.warn(`üîÑ Operation failed. Retrying (${attempt + 1}/${maxRetries + 1})`, error.message);\n        }\n        \n        // Calculate delay with exponential backoff\n        const exponentialDelay = baseDelay * Math.pow(2, attempt);\n        \n        // Add jitter if enabled (¬±10% variation)\n        const finalDelay = jitter \n          ? exponentialDelay * (0.9 + Math.random() * 0.2) \n          : exponentialDelay;\n        \n        // Wait before retrying\n        await delay(finalDelay);\n      }\n    }\n    \n    // If we get here, all retries failed\n    throw lastError;\n  };\n};\n\n/**\n * Error class for network-related errors\n */\nexport class NetworkError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n}\n\n/**\n * Error class for rate limiting\n */\nexport class RateLimitError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"RateLimitError\";\n    this.retryAfter = null; // Can be set if server returns Retry-After header\n  }\n  \n  /**\n   * Set retry time from headers\n   * @param {Headers} headers - Response headers\n   */\n  setRetryAfterFromHeaders(headers) {\n    const retryAfter = headers.get('Retry-After');\n    if (retryAfter) {\n      // Convert to milliseconds (either seconds or date string)\n      if (/^\\d+$/.test(retryAfter)) {\n        // It's seconds\n        this.retryAfter = parseInt(retryAfter, 10) * 1000;\n      } else {\n        // It's a date string\n        const retryDate = new Date(retryAfter);\n        this.retryAfter = retryDate.getTime() - Date.now();\n      }\n    }\n  }\n}\n\n/**\n * Safe JSON parsing with fallback\n * @param {string} jsonString - JSON string to parse\n * @param {*} fallback - Fallback value if parsing fails\n * @returns {*} Parsed object or fallback\n */\nexport const safeJsonParse = (jsonString, fallback = null) => {\n  try {\n    return JSON.parse(jsonString);\n  } catch (error) {\n    console.warn('üîç JSON parse failed, using fallback:', error.message);\n    return fallback;\n  }\n};\n\n/**\n * Get nested object property safely\n * @param {Object} obj - Object to access\n * @param {string} path - Dot-separated path (e.g., 'user.profile.name')\n * @param {*} defaultValue - Default value if path doesn't exist\n * @returns {*} Value at path or default\n */\nexport const getIn = (obj, path, defaultValue = undefined) => {\n  const keys = path.split('.');\n  let result = obj;\n  \n  for (const key of keys) {\n    if (result == null || typeof result !== 'object') {\n      return defaultValue;\n    }\n    result = result[key];\n  }\n  \n  return result !== undefined ? result : defaultValue;\n};\n\n/**\n * Log error to chrome storage for debugging\n * @param {string} context - Context where error occurred\n * @param {Error|string} error - Error object or message\n * @param {Object} metadata - Additional metadata\n */\nexport const logError = async (context, error, metadata = {}) => {\n  const errorLog = {\n    timestamp: new Date().toISOString(),\n    context,\n    message: error?.message || error,\n    stack: error?.stack,\n    metadata,\n    userAgent: navigator.userAgent\n  };\n  \n  try {\n    // Get existing error logs\n    const result = await new Promise(resolve => {\n      chrome.storage.local.get(['errorLogs'], resolve);\n    });\n    \n    const existingLogs = result.errorLogs || [];\n    \n    // Keep only last 100 error logs to prevent storage bloat\n    const updatedLogs = [...existingLogs, errorLog].slice(-100);\n    \n    // Save back to storage\n    await new Promise(resolve => {\n      chrome.storage.local.set({ errorLogs: updatedLogs }, resolve);\n    });\n    \n    console.error(`üìù Error logged [${context}]:`, error);\n    \n  } catch (storageError) {\n    console.error('‚ùå Failed to log error to storage:', storageError);\n  }\n};\n\n/**\n * Throttle function calls\n * @param {Function} func - Function to throttle\n * @param {number} delay - Delay in milliseconds\n * @returns {Function} Throttled function\n */\nexport const throttle = (func, delay) => {\n  let timeoutId;\n  let lastExecTime = 0;\n  \n  return (...args) => {\n    const currentTime = Date.now();\n    \n    if (currentTime - lastExecTime > delay) {\n      func(...args);\n      lastExecTime = currentTime;\n    } else {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        func(...args);\n        lastExecTime = Date.now();\n      }, delay - (currentTime - lastExecTime));\n    }\n  };\n};\n\n/**\n * Debounce function calls\n * @param {Function} func - Function to debounce\n * @param {number} delay - Delay in milliseconds\n * @returns {Function} Debounced function\n */\nexport const debounce = (func, delay) => {\n  let timeoutId;\n  \n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func(...args), delay);\n  };\n};\n\n/**\n * Format file size in human readable format\n * @param {number} bytes - Size in bytes\n * @returns {string} Formatted size\n */\nexport const formatFileSize = (bytes) => {\n  if (bytes === 0) return '0 Bytes';\n  \n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n};\n\n/**\n * Format timestamp to relative time\n * @param {string|Date} timestamp - Timestamp to format\n * @returns {string} Relative time string\n */\nexport const formatRelativeTime = (timestamp) => {\n  const now = Date.now();\n  const time = new Date(timestamp).getTime();\n  const diff = now - time;\n  \n  const minute = 60 * 1000;\n  const hour = 60 * minute;\n  const day = 24 * hour;\n  const week = 7 * day;\n  const month = 30 * day;\n  \n  if (diff < minute) return 'just now';\n  if (diff < hour) return `${Math.floor(diff / minute)}m ago`;\n  if (diff < day) return `${Math.floor(diff / hour)}h ago`;\n  if (diff < week) return `${Math.floor(diff / day)}d ago`;\n  if (diff < month) return `${Math.floor(diff / week)}w ago`;\n  return `${Math.floor(diff / month)}mo ago`;\n};\n\n/**\n * Generate a simple hash from string\n * @param {string} str - String to hash\n * @returns {string} Hash string\n */\nexport const simpleHash = (str) => {\n  let hash = 0;\n  if (str.length === 0) return hash.toString();\n  \n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  \n  return Math.abs(hash).toString(36);\n};\n\n/**\n * Check if URL is valid\n * @param {string} urlString - URL to validate\n * @returns {boolean} True if valid URL\n */\nexport const isValidUrl = (urlString) => {\n  try {\n    new URL(urlString);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Sanitize text for safe storage/display\n * @param {string} text - Text to sanitize\n * @returns {string} Sanitized text\n */\nexport const sanitizeText = (text) => {\n  if (typeof text !== 'string') return '';\n  \n  return text\n    .replace(/[<>]/g, '') // Remove potential HTML\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim()\n    .substring(0, 10000); // Limit length\n};\n\n/**\n * Performance monitoring wrapper\n * @param {string} label - Performance label\n * @param {Function} fn - Function to monitor\n * @returns {Function} Wrapped function with performance monitoring\n */\nexport const withPerformanceMonitoring = (label, fn) => {\n  return async (...args) => {\n    const startTime = performance.now();\n    \n    try {\n      const result = await fn(...args);\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      if (duration > 100) { // Log slow operations (>100ms)\n        console.warn(`‚è±Ô∏è Slow operation [${label}]: ${duration.toFixed(2)}ms`);\n      }\n      \n      return result;\n      \n    } catch (error) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      console.error(`‚ùå Operation failed [${label}] after ${duration.toFixed(2)}ms:`, error);\n      throw error;\n    }\n  };\n};\n\nconsole.log('üõ†Ô∏è XSaved v2 Helpers utility loaded - ready for error handling and utilities'); ","/**\n * XSaved Extension v2 - X.com API Fetcher\n * Real implementation for fetching bookmarks from X.com GraphQL API\n * Adapted from proven v1 extension with enhancements for IndexedDB integration\n */\n\nimport { NetworkError, RateLimitError } from './helpers.js';\n\n// Constants\nconst TWITTER_URL = 'https://x.com';\nconst BOOKMARK_ENDPOINT = `${TWITTER_URL}/i/api/graphql/QUjXply7fA7fk05FRyajEg/Bookmarks`;\n\n/**\n * Main function to fetch bookmarks from X.com API\n * @param {string|null} cursor - Pagination cursor for next batch\n * @param {string|null} csrfTokenOverride - Optional CSRF token override\n * @param {boolean} isDeltaSync - Whether this is a delta sync (smaller batches)\n * @returns {Promise<{bookmarks: Array, nextCursor: string|null}>}\n */\nexport const fetchBookmarksV2 = async (cursor = null, csrfTokenOverride = null, isDeltaSync = false) => {\n  console.log(`üì• Fetching bookmarks batch (delta: ${isDeltaSync}, cursor: ${cursor ? 'yes' : 'none'})`);\n  \n  // Adjust count for delta sync - fetch smaller batches to find new content faster\n  const batchSize = isDeltaSync ? 50 : 100;\n  const variables = { \n    count: batchSize, \n    includePromotedContent: true, \n    ...(cursor && { cursor }) \n  };\n  \n  // X.com GraphQL features - these are required for the API to work properly\n  const features = {\n    graphql_timeline_v2_bookmark_timeline: true,\n    rweb_tipjar_consumption_enabled: true,\n    responsive_web_graphql_exclude_directive_enabled: true,\n    verified_phone_label_enabled: false,\n    creator_subscriptions_tweet_preview_api_enabled: true,\n    responsive_web_graphql_timeline_navigation_enabled: true,\n    responsive_web_graphql_skip_user_profile_image_extensions_enabled: false,\n    communities_web_enable_tweet_community_results_fetch: true,\n    c9s_tweet_anatomy_moderator_badge_enabled: true,\n    articles_preview_enabled: true,\n    responsive_web_edit_tweet_api_enabled: true,\n    graphql_is_translatable_rweb_tweet_is_translatable_enabled: true,\n    view_counts_everywhere_api_enabled: true,\n    longform_notetweets_consumption_enabled: true,\n    responsive_web_twitter_article_tweet_consumption_enabled: true,\n    tweet_awards_web_tipping_enabled: false,\n    creator_subscriptions_quote_tweet_preview_enabled: false,\n    freedom_of_speech_not_reach_fetch_enabled: true,\n    standardized_nudges_misinfo: true,\n    tweet_with_visibility_results_prefer_gql_limited_actions_policy_enabled: true,\n    rweb_video_timestamps_enabled: true,\n    longform_notetweets_rich_text_read_enabled: true,\n    longform_notetweets_inline_media_enabled: true,\n    responsive_web_enhance_cards_enabled: false\n  };\n\n  // Get CSRF token\n  let csrfToken = csrfTokenOverride;\n  if (!csrfToken) {\n    try {\n      csrfToken = await getCsrfToken();\n      if (!csrfToken) {\n        console.warn('‚ö†Ô∏è CSRF token not found in cookies');\n      }\n    } catch (error) {\n      console.error('‚ùå Error getting CSRF token:', error.message);\n    }\n  }\n\n  // Construct headers required by X.com API\n  const headers = {\n    \"accept\": \"*/*\",\n    \"accept-language\": \"en-US,en;q=0.9\",\n    \"authorization\": \"Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA\",\n    \"content-type\": \"application/json\",\n    \"x-twitter-active-user\": \"yes\",\n    \"x-twitter-auth-type\": \"OAuth2Session\",\n    \"x-twitter-client-language\": \"en\",\n    \"x-csrf-token\": csrfToken || '',\n    \"x-client-transaction-id\": `${Date.now()}-${Math.random().toString(36).substring(2)}`,\n    \"x-client-uuid\": generateClientUUID()\n  };\n  \n  // Construct the URL with query parameters\n  const url = `${BOOKMARK_ENDPOINT}?variables=${encodeURIComponent(JSON.stringify(variables))}&features=${encodeURIComponent(JSON.stringify(features))}`;\n  \n  try {\n    console.log(`üåê Making request to X.com API...`);\n    \n    const response = await fetch(url, {\n      headers,\n      referrer: `${TWITTER_URL}/i/bookmarks`,\n      referrerPolicy: \"strict-origin-when-cross-origin\",\n      method: \"GET\",\n      mode: \"cors\",\n      credentials: \"include\",\n    });\n    \n    if (!response.ok) {\n      if (response.status === 429) {\n        throw new RateLimitError(`Rate limit reached: ${response.status}`);\n      }\n      throw new NetworkError(`HTTP error! status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    let { bookmarks, nextCursor } = processBookmarksResponse(data);\n    \n    // Enhance bookmarks with media URLs for IndexedDB\n    bookmarks = enhanceBookmarksWithMetadata(bookmarks);\n    \n    // Check if cursor is valid (not same as current one)\n    nextCursor = checkNextCursor(cursor, nextCursor);\n    \n    console.log(`‚úÖ Fetched ${bookmarks.length} bookmarks (next cursor: ${nextCursor ? 'yes' : 'none'})`);\n    \n    return { bookmarks, nextCursor };\n    \n  } catch (error) {\n    if (error instanceof RateLimitError || error instanceof NetworkError) {\n      throw error;\n    }\n    \n    if (error.message.includes('HTTP error! status:')) {\n      console.warn(\"‚ö†Ô∏è Possible rate limit hit. Consider backing off.\");\n      throw new NetworkError(error.message);\n    }\n    \n    console.error('‚ùå Unexpected error in fetchBookmarksV2:', error);\n    throw error;\n  }\n};\n\n/**\n * Process the raw response from X.com bookmarks API\n * @param {Object} data - Raw API response\n * @returns {Object} Processed bookmarks and pagination cursor\n */\nexport const processBookmarksResponse = (data) => {\n  try {\n    const entries = data?.data?.bookmark_timeline_v2?.timeline?.instructions?.[0]?.entries || [];\n    \n    const bookmarks = entries\n      .filter(entry => entry?.entryId?.startsWith('tweet-'))\n      .map(entry => {\n        const result = entry?.content?.itemContent?.tweet_results?.result;\n        const legacy = result?.legacy;\n        const user = result?.core?.user_results?.result?.legacy;\n\n        return {\n          id: result?.rest_id,\n          text: legacy?.full_text,\n          author: user?.screen_name,\n          created_at: legacy?.created_at,\n          // Store full data for media extraction\n          FULL_DATA: result,\n        };\n      })\n      .filter(bookmark => bookmark.id && bookmark.text); // Remove entries with missing essential data\n\n    const nextCursor = entries.find(entry => entry?.entryId?.startsWith('cursor-bottom-'))?.content?.value;\n    \n    console.log(`üìã Processed ${bookmarks.length} bookmarks from API response`);\n    \n    return { bookmarks, nextCursor };\n    \n  } catch (error) {\n    console.error(\"‚ùå Error processing bookmarks response:\", error);\n    // Return empty results on error rather than breaking\n    return { bookmarks: [], nextCursor: null };\n  }\n};\n\n/**\n * Enhance bookmarks with metadata for IndexedDB storage\n * @param {Array} bookmarks - Raw bookmarks from API\n * @returns {Array} Enhanced bookmarks with media URLs and clean data\n */\nexport const enhanceBookmarksWithMetadata = (bookmarks) => {\n  return bookmarks.map(bookmark => {\n    const enhanced = {\n      id: bookmark.id,\n      text: bookmark.text,\n      author: bookmark.author,\n      created_at: bookmark.created_at,\n      media_urls: extractMediaUrls(bookmark.FULL_DATA)\n    };\n    \n    // Remove FULL_DATA to keep storage lean\n    return enhanced;\n  });\n};\n\n/**\n * Extract media URLs from tweet data\n * @param {Object} tweetData - Full tweet data from API\n * @returns {Array} Array of media URLs\n */\nexport const extractMediaUrls = (tweetData) => {\n  const media_urls = [];\n  \n  try {\n    // Extract photos\n    const media = tweetData?.legacy?.entities?.media || [];\n    media.forEach(item => {\n      if (item.type === 'photo' && item.media_url_https) {\n        media_urls.push(item.media_url_https);\n      }\n    });\n    \n    // Extract video thumbnails\n    const extendedEntities = tweetData?.legacy?.extended_entities?.media || [];\n    extendedEntities.forEach(item => {\n      if (item.type === 'video' && item.media_url_https) {\n        media_urls.push(item.media_url_https);\n      }\n    });\n    \n  } catch (error) {\n    console.warn('‚ö†Ô∏è Error extracting media URLs:', error);\n  }\n  \n  return [...new Set(media_urls)]; // Remove duplicates\n};\n\n/**\n * Get CSRF token from browser cookies\n * @returns {Promise<string|null>} CSRF token or null if not found\n */\nexport const getCsrfToken = () => {\n  return new Promise((resolve) => {\n    chrome.cookies.get({ url: TWITTER_URL, name: 'ct0' }, (cookie) => {\n      if (chrome.runtime.lastError) {\n        console.error('‚ùå Error getting CSRF token:', chrome.runtime.lastError);\n        resolve(null);\n        return;\n      }\n      \n      if (cookie) {\n        console.log('üîë CSRF token retrieved successfully');\n        resolve(cookie.value);\n      } else {\n        console.log('‚ö†Ô∏è No CSRF token found in cookies');\n        resolve(null);\n      }\n    });\n  });\n};\n\n/**\n * Check if user is logged into X.com by verifying CSRF token\n * @returns {Promise<boolean>} True if logged in, false otherwise\n */\nexport const checkXLoginStatus = async () => {\n  try {\n    const token = await getCsrfToken();\n    if (!token) {\n      console.log('‚ùå User not logged into X.com (no CSRF token)');\n      return false;\n    }\n    \n    console.log('‚úÖ User is logged into X.com');\n    return true;\n    \n  } catch (error) {\n    console.error('‚ùå Error checking X login status:', error);\n    return false;\n  }\n};\n\n/**\n * Generate a client UUID for request headers\n * @returns {string} UUID string\n */\nconst generateClientUUID = () => {\n  try {\n    return crypto.randomUUID();\n  } catch (error) {\n    // Fallback for environments without crypto.randomUUID\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c == 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }\n};\n\n/**\n * Check if cursor is different from previous one (indicates more data available)\n * @param {string|null} currentCursor - Current cursor\n * @param {string|null} nextCursor - Next cursor from API\n * @returns {string|null} Next cursor or null if no more data\n */\nconst checkNextCursor = (currentCursor, nextCursor) => {\n  return nextCursor === currentCursor ? null : nextCursor;\n};\n\nconsole.log('üì° XSaved v2 Fetcher utility loaded - ready for X.com API integration'); ","/**\n * XSaved Extension v2 - Communication Utilities\n * Robust message passing between service worker, content scripts, and popup\n * Adapted from proven v1 extension with enhancements\n */\n\n/**\n * Safely notify content script in a specific tab\n * @param {number} tabId - Tab ID to send message to\n * @param {Object} message - Message object to send\n * @returns {Promise} Promise that resolves with response or silently on error\n */\nexport const notifyContentScript = (tabId, message) => new Promise((resolve, reject) => {\n  if (!tabId) {\n    resolve(); // Don't reject, just resolve silently\n    return;\n  }\n  \n  // Check if tab exists first\n  chrome.tabs.get(tabId, (tab) => {\n    if (chrome.runtime.lastError) {\n      // Tab doesn't exist, resolve silently\n      console.log(`üì± Tab ${tabId} not found (normal during navigation)`);\n      resolve();\n      return;\n    }\n    \n    // Check if tab is still valid (not chrome:// or extension pages)\n    if (!tab.url || tab.url.startsWith('chrome://') || tab.url.startsWith('chrome-extension://')) {\n      console.log(`üì± Tab ${tabId} not valid for messaging`);\n      resolve();\n      return;\n    }\n    \n    // Tab exists and is valid, send message\n    chrome.tabs.sendMessage(tabId, message, (response) => {\n      if (chrome.runtime.lastError) {\n        // Content script not available, resolve silently (common during navigation)\n        console.log(`üì± Content script not available in tab ${tabId} (normal during reload/navigation)`);\n        resolve();\n      } else {\n        console.log(`üì± Message sent to tab ${tabId}:`, message.action || 'unknown');\n        resolve(response);\n      }\n    });\n  });\n});\n\n/**\n * Safely notify popup (if open)\n * @param {Object} message - Message object to send\n */\nexport const notifyPopup = (message) => {\n  try {\n    chrome.runtime.sendMessage(message);\n    console.log(`ü™ü Message sent to popup:`, message.action || 'unknown');\n  } catch (error) {\n    // Popup might not be open, fail silently\n    console.log(`ü™ü Popup not available (normal when closed)`);\n  }\n};\n\n/**\n * Update progress in content script with enhanced error handling\n * @param {number} current - Current progress count\n * @param {number} total - Total expected count\n * @param {number} tabId - Tab ID to notify\n * @param {Object} metadata - Additional progress metadata\n */\nexport const updateProgress = async (current, total, tabId, metadata = {}) => {\n  if (!tabId) return;\n  \n  try {\n    const percentage = total > 0 ? Math.round((current / total) * 100) : 0;\n    const progressMessage = { \n      action: \"updateProgress\", \n      bookmarkCount: current,\n      totalBookmarks: total,\n      percentage: percentage,\n      phase: metadata.phase || 'processing',\n      message: metadata.message || `Processing ${current}/${total}...`,\n      ...metadata\n    };\n    \n    await notifyContentScript(tabId, progressMessage);\n    \n  } catch (error) {\n    // Silently handle tab/content script errors\n    console.log(\"üì± Tab unavailable for progress update (normal during long operations)\");\n  }\n};\n\n/**\n * Broadcast message to all X.com tabs\n * @param {Object} message - Message to broadcast\n * @param {Object} options - Broadcast options\n * @param {boolean} options.activeOnly - Only send to active tabs\n * @returns {Promise<Array>} Array of responses from tabs\n */\nexport const broadcastToXTabs = async (message, options = {}) => {\n  const { activeOnly = false } = options;\n  \n  return new Promise((resolve) => {\n    // Query for X.com tabs\n    const queryOptions = { \n      url: [\"https://twitter.com/*\", \"https://x.com/*\"]\n    };\n    \n    if (activeOnly) {\n      queryOptions.active = true;\n    }\n    \n    chrome.tabs.query(queryOptions, async (tabs) => {\n      console.log(`üì° Broadcasting to ${tabs.length} X.com tabs:`, message.action || 'unknown');\n      \n      const responses = [];\n      \n      // Send to all matching tabs\n      for (const tab of tabs) {\n        try {\n          const response = await notifyContentScript(tab.id, message);\n          responses.push({ tabId: tab.id, response });\n        } catch (error) {\n          responses.push({ tabId: tab.id, error: error.message });\n        }\n      }\n      \n      resolve(responses);\n    });\n  });\n};\n\n/**\n * Send message with retry logic\n * @param {number} tabId - Tab ID to send message to\n * @param {Object} message - Message to send\n * @param {Object} options - Retry options\n * @param {number} options.maxRetries - Maximum retry attempts\n * @param {number} options.retryDelay - Delay between retries in ms\n * @returns {Promise} Promise that resolves with response\n */\nexport const sendMessageWithRetry = async (tabId, message, options = {}) => {\n  const { maxRetries = 3, retryDelay = 1000 } = options;\n  \n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      const response = await notifyContentScript(tabId, message);\n      return response;\n      \n    } catch (error) {\n      console.warn(`üîÑ Message retry ${attempt + 1}/${maxRetries} for tab ${tabId}`);\n      \n      if (attempt === maxRetries - 1) {\n        throw error;\n      }\n      \n      // Wait before retry\n      await new Promise(resolve => setTimeout(resolve, retryDelay));\n    }\n  }\n};\n\n/**\n * Check if content script is available in tab\n * @param {number} tabId - Tab ID to check\n * @returns {Promise<boolean>} True if content script is available\n */\nexport const isContentScriptAvailable = async (tabId) => {\n  try {\n    const response = await notifyContentScript(tabId, { action: 'ping' });\n    return !!response;\n  } catch (error) {\n    return false;\n  }\n};\n\n/**\n * Get active X.com tab ID\n * @returns {Promise<number|null>} Active X.com tab ID or null\n */\nexport const getActiveXTabId = async () => {\n  return new Promise((resolve) => {\n    chrome.tabs.query({ \n      active: true, \n      currentWindow: true,\n      url: [\"https://twitter.com/*\", \"https://x.com/*\"]\n    }, (tabs) => {\n      resolve(tabs.length > 0 ? tabs[0].id : null);\n    });\n  });\n};\n\n/**\n * Wait for content script to be ready in tab\n * @param {number} tabId - Tab ID to wait for\n * @param {number} timeout - Timeout in milliseconds\n * @returns {Promise<boolean>} True if content script becomes available\n */\nexport const waitForContentScript = async (tabId, timeout = 10000) => {\n  const startTime = Date.now();\n  \n  while (Date.now() - startTime < timeout) {\n    if (await isContentScriptAvailable(tabId)) {\n      return true;\n    }\n    \n    // Wait 500ms before checking again\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n  \n  return false;\n};\n\n/**\n * Enhanced state update broadcaster with filtering\n * @param {Object} state - State object to broadcast\n * @param {Object} options - Broadcast options\n * @param {Array} options.includeActions - Only send to tabs expecting these actions\n * @param {boolean} options.onlyActiveTab - Only send to active tab\n */\nexport const broadcastStateUpdate = async (state, options = {}) => {\n  const { includeActions = [], onlyActiveTab = false } = options;\n  \n  const stateMessage = {\n    action: \"stateUpdate\",\n    ...state,\n    timestamp: Date.now()\n  };\n  \n  try {\n    if (onlyActiveTab) {\n      const activeTabId = await getActiveXTabId();\n      if (activeTabId) {\n        await notifyContentScript(activeTabId, stateMessage);\n      }\n    } else {\n      await broadcastToXTabs(stateMessage);\n    }\n    \n    // Also notify popup\n    notifyPopup(stateMessage);\n    \n  } catch (error) {\n    console.error('‚ùå Error broadcasting state update:', error);\n  }\n};\n\n/**\n * Message queue for handling high-frequency updates\n */\nclass MessageQueue {\n  constructor(options = {}) {\n    this.queue = [];\n    this.processing = false;\n    this.maxQueueSize = options.maxQueueSize || 100;\n    this.processInterval = options.processInterval || 100;\n  }\n  \n  /**\n   * Add message to queue\n   * @param {number} tabId - Tab ID\n   * @param {Object} message - Message to queue\n   */\n  enqueue(tabId, message) {\n    // Prevent queue overflow\n    if (this.queue.length >= this.maxQueueSize) {\n      console.warn('üì¨ Message queue full, dropping oldest message');\n      this.queue.shift();\n    }\n    \n    this.queue.push({ tabId, message, timestamp: Date.now() });\n    this.processQueue();\n  }\n  \n  /**\n   * Process queued messages\n   */\n  async processQueue() {\n    if (this.processing || this.queue.length === 0) return;\n    \n    this.processing = true;\n    \n    while (this.queue.length > 0) {\n      const { tabId, message } = this.queue.shift();\n      \n      try {\n        await notifyContentScript(tabId, message);\n      } catch (error) {\n        console.warn('üì¨ Queued message failed:', error.message);\n      }\n      \n      // Small delay to prevent overwhelming\n      await new Promise(resolve => setTimeout(resolve, this.processInterval));\n    }\n    \n    this.processing = false;\n  }\n}\n\n// Global message queue instance\nexport const messageQueue = new MessageQueue();\n\n/**\n * Queue message for delivery (useful for high-frequency updates)\n * @param {number} tabId - Tab ID\n * @param {Object} message - Message to queue\n */\nexport const queueMessage = (tabId, message) => {\n  messageQueue.enqueue(tabId, message);\n};\n\n/**\n * Heartbeat system to maintain connection with content scripts\n */\nclass HeartbeatManager {\n  constructor() {\n    this.connectedTabs = new Set();\n    this.heartbeatInterval = null;\n  }\n  \n  start() {\n    if (this.heartbeatInterval) return;\n    \n    console.log('üíì Starting heartbeat manager');\n    \n    this.heartbeatInterval = setInterval(async () => {\n      await this.checkConnections();\n    }, 30000); // Check every 30 seconds\n  }\n  \n  stop() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n      console.log('üíì Heartbeat manager stopped');\n    }\n  }\n  \n  async checkConnections() {\n    const tabs = await new Promise(resolve => {\n      chrome.tabs.query({ url: [\"https://twitter.com/*\", \"https://x.com/*\"] }, resolve);\n    });\n    \n    for (const tab of tabs) {\n      const isConnected = await isContentScriptAvailable(tab.id);\n      \n      if (isConnected) {\n        this.connectedTabs.add(tab.id);\n      } else {\n        this.connectedTabs.delete(tab.id);\n      }\n    }\n    \n    console.log(`üíì Heartbeat: ${this.connectedTabs.size} content scripts connected`);\n  }\n  \n  isTabConnected(tabId) {\n    return this.connectedTabs.has(tabId);\n  }\n}\n\n// Global heartbeat manager\nexport const heartbeatManager = new HeartbeatManager();\n\nconsole.log('üì° XSaved v2 Communicator utility loaded - ready for message passing'); ","/**\n * XSaved Extension v2 - Enhanced Service Worker\n * Combines proven smart scheduling with IndexedDB and Search Engine\n */\n// Import our Components 1 & 2 (TypeScript source - Webpack will bundle)\nimport { db } from '../db/index';\nimport { searchEngine } from '../search/index';\n// Import existing proven utilities (keep .js extension for webpack)\nimport { fetchBookmarksV2, getCsrfToken, checkXLoginStatus } from './utils/fetcher.js';\nimport { notifyContentScript, notifyPopup } from './utils/communicator.js';\nimport { delay, RateLimitError } from './utils/helpers.js';\n// ===============================\n// PROVEN SCHEDULING CONSTANTS (Keep from background.js)\n// ===============================\nconst SCHEDULE_INTERVALS = {\n    FREQUENT: 5, // 5 minutes - when user is active\n    NORMAL: 15, // 15 minutes - default\n    INFREQUENT: 60, // 1 hour - when user is inactive\n    OFFLINE: 240 // 4 hours - when user seems offline\n};\nconst AUTOMATIC_MIN_FETCH_INTERVAL = SCHEDULE_INTERVALS.FREQUENT * 60 * 1000; // 5 minutes\nconst AUTOMATIC_SCHEDULED_FETCH_INTERVAL_IN_MINUTES = SCHEDULE_INTERVALS.NORMAL; // 15 minutes\nconst MAX_RETRIES = 3;\nconst RATE_LIMIT_DELAY = 1500; // 1.5 seconds\nconst INITIAL_REQUESTS_LEFT = 20;\nconst USER_ACTIVITY_THRESHOLD = 2 * 60 * 60 * 1000; // 2 hours\nconst EXPONENTIAL_BACKOFF_BASE = 2;\nconst MAX_BACKOFF_MINUTES = 240; // 4 hours max backoff\n// ===============================\n// STATE MANAGEMENT (Keep from background.js)\n// ===============================\nlet currentScheduleInterval = SCHEDULE_INTERVALS.NORMAL;\nlet consecutiveFailures = 0;\nlet lastUserActivity = Date.now();\nlet authSession = null;\nlet isExtracting = false;\nlet requestsLeft = INITIAL_REQUESTS_LEFT;\nlet bookmarksTabId = null;\nlet estimatedTotalBookmarks = 0;\n// Delta sync variables (Keep existing logic)\nlet lastBookmarkId = null;\nlet lastSyncTimestamp = null;\nlet isDeltaSync = false;\nlet newestBookmarkId = null;\n// Extraction state tracking\nlet extractionState = {\n    phase: 'idle', // 'idle', 'twitter_api_fetch', 'indexeddb_save'\n    startTime: null,\n    message: '',\n    bookmarkCount: 0,\n    totalBookmarks: 0,\n    isBackground: false,\n    percentage: 0\n};\n// ===============================\n// ENHANCED INITIALIZATION\n// ===============================\nclass ExtensionServiceWorker {\n    constructor() {\n        this.initialized = false;\n        this.db = null;\n        this.searchEngine = null;\n        this.initialized = false;\n        this.db = null;\n        this.searchEngine = null;\n    }\n    async initialize() {\n        if (this.initialized)\n            return;\n        try {\n            console.log('üöÄ Initializing Enhanced Service Worker...');\n            // Initialize IndexedDB (Component 1) - USING STATIC IMPORTS\n            console.log('üìÄ Initializing IndexedDB...');\n            try {\n                await db.initialize();\n                this.db = db;\n                console.log('‚úÖ IndexedDB initialized successfully');\n            }\n            catch (error) {\n                console.error('‚ùå Failed to initialize IndexedDB:', error);\n                this.db = null;\n            }\n            // Initialize Search Engine (Component 2) - USING STATIC IMPORTS\n            console.log('üîç Initializing Search Engine...');\n            try {\n                this.searchEngine = searchEngine;\n                console.log('‚úÖ Search Engine initialized successfully');\n            }\n            catch (error) {\n                console.error('‚ùå Failed to initialize Search Engine:', error);\n                this.searchEngine = null;\n            }\n            // Load existing sync state from chrome.storage\n            await this.loadSyncState();\n            // Set up smart scheduling (keep existing logic)\n            this.setupSmartScheduling();\n            console.log('‚úÖ Enhanced Service Worker initialized successfully');\n            this.initialized = true;\n        }\n        catch (error) {\n            console.error('‚ùå Service Worker initialization failed:', error);\n            throw error;\n        }\n    }\n    async loadSyncState() {\n        return new Promise((resolve) => {\n            chrome.storage.local.get([\n                'lastBookmarkId',\n                'lastSyncTimestamp',\n                'syncMode',\n                'requestsLeft'\n            ], (result) => {\n                lastBookmarkId = result.lastBookmarkId || null;\n                lastSyncTimestamp = result.lastSyncTimestamp || null;\n                requestsLeft = result.requestsLeft || INITIAL_REQUESTS_LEFT;\n                // Determine if we can do delta sync\n                const timeSinceLastSync = lastSyncTimestamp ? Date.now() - lastSyncTimestamp : null;\n                isDeltaSync = !!(lastBookmarkId && timeSinceLastSync < 24 * 60 * 60 * 1000);\n                console.log('üìä Loaded sync state:', {\n                    lastBookmarkId: lastBookmarkId ? `${lastBookmarkId.substring(0, 15)}...` : null,\n                    isDeltaSync,\n                    timeSinceLastSync: timeSinceLastSync ? Math.round(timeSinceLastSync / 60000) + 'min' : null\n                });\n                resolve();\n            });\n        });\n    }\n    setupSmartScheduling() {\n        // Keep existing alarm logic\n        chrome.alarms.onAlarm.addListener(async (alarm) => {\n            if (alarm.name === 'fetchBookmarks') {\n                if (await this.isAllowedToAutomaticFetch()) {\n                    console.log('‚è∞ SMART ALARM: Fetching bookmarks');\n                    await this.backgroundFetch();\n                }\n            }\n        });\n        // Schedule initial alarm\n        this.scheduleNextFetch();\n    }\n    async isAllowedToAutomaticFetch() {\n        const now = Date.now();\n        // Check if extraction is already in progress\n        if (isExtracting) {\n            console.log('‚è∏Ô∏è Extraction already in progress, skipping automatic fetch');\n            return false;\n        }\n        // Check minimum interval\n        if (lastSyncTimestamp && (now - lastSyncTimestamp) < AUTOMATIC_MIN_FETCH_INTERVAL) {\n            console.log('‚è∏Ô∏è Too soon since last sync, skipping automatic fetch');\n            return false;\n        }\n        // Check if user is logged in to X.com\n        const isLoggedIn = await this.checkXLoginStatus();\n        if (!isLoggedIn) {\n            console.log('‚è∏Ô∏è User not logged in to X.com, skipping automatic fetch');\n            return false;\n        }\n        return true;\n    }\n    async checkXLoginStatus() {\n        return await checkXLoginStatus();\n    }\n    async backgroundFetch() {\n        updateExtractionState({\n            isBackground: true,\n            message: 'Background sync starting...'\n        });\n        await extractAllBookmarks();\n    }\n    scheduleNextFetch() {\n        // Clear any existing alarm\n        chrome.alarms.clear('fetchBookmarks');\n        // Schedule next alarm based on current interval\n        const nextFetchInMinutes = currentScheduleInterval;\n        chrome.alarms.create('fetchBookmarks', { delayInMinutes: nextFetchInMinutes });\n        console.log(`‚è∞ Next automatic fetch scheduled in ${nextFetchInMinutes} minutes`);\n    }\n    updateScheduleInterval() {\n        const timeSinceActivity = Date.now() - lastUserActivity;\n        const oldInterval = currentScheduleInterval;\n        if (timeSinceActivity < USER_ACTIVITY_THRESHOLD) {\n            currentScheduleInterval = SCHEDULE_INTERVALS.FREQUENT;\n        }\n        else if (timeSinceActivity < USER_ACTIVITY_THRESHOLD * 2) {\n            currentScheduleInterval = SCHEDULE_INTERVALS.NORMAL;\n        }\n        else if (timeSinceActivity < USER_ACTIVITY_THRESHOLD * 4) {\n            currentScheduleInterval = SCHEDULE_INTERVALS.INFREQUENT;\n        }\n        else {\n            currentScheduleInterval = SCHEDULE_INTERVALS.OFFLINE;\n        }\n        if (oldInterval !== currentScheduleInterval) {\n            console.log(`üìä Schedule interval updated: ${oldInterval}min ‚Üí ${currentScheduleInterval}min`);\n            this.scheduleNextFetch();\n        }\n    }\n}\n// ===============================\n// ENHANCED BOOKMARK SAVING (NEW: IndexedDB Integration)\n// ===============================\nconst saveBookmarkToLocal = async (bookmark, userTags = []) => {\n    try {\n        // Ensure service worker is initialized\n        await serviceWorker.initialize();\n        // Create BookmarkEntity for Component 1\n        const bookmarkEntity = {\n            id: bookmark.id,\n            text: bookmark.text || '',\n            author: bookmark.author || '',\n            created_at: bookmark.created_at || new Date().toISOString(),\n            bookmark_timestamp: new Date().toISOString(),\n            tags: userTags.length > 0 ? userTags : (bookmark.tags || []),\n            media_urls: bookmark.media_urls || [],\n            // Add search tokenization for Component 2\n            textTokens: tokenizeText(bookmark.text || '')\n        };\n        // Save to IndexedDB (Component 1) - TEMPORARILY USE CHROME.STORAGE FOR TESTING\n        if (serviceWorker.db) {\n            const result = await serviceWorker.db.addBookmark(bookmarkEntity);\n            if (result.success) {\n                console.log(`‚úÖ Saved bookmark ${bookmark.id} to IndexedDB`);\n                extractionState.bookmarkCount++;\n                broadcastStateUpdate();\n                return result.data;\n            }\n            else {\n                console.error('‚ùå Failed to save bookmark:', result.error);\n                return null;\n            }\n        }\n        else {\n            // Fallback to chrome.storage.local for testing\n            console.log('üíæ Saving bookmark to chrome.storage.local (testing mode)');\n            const key = `bookmark_${bookmark.id}`;\n            await chrome.storage.local.set({ [key]: bookmarkEntity });\n            console.log(`‚úÖ Saved bookmark ${bookmark.id} to local storage`);\n            extractionState.bookmarkCount++;\n            broadcastStateUpdate();\n            return bookmarkEntity;\n        }\n    }\n    catch (error) {\n        console.error('‚ùå Error saving bookmark to local storage:', error);\n        return null;\n    }\n};\n// ===============================\n// ENHANCED EXTRACTION FLOW (Keep existing + IndexedDB)\n// ===============================\nconst extractAllBookmarks = async () => {\n    if (isExtracting) {\n        console.log('‚ö†Ô∏è Extraction already in progress');\n        return;\n    }\n    await serviceWorker.initialize();\n    isExtracting = true;\n    let cursor = null;\n    let allExtractedBookmarks = [];\n    let retryCount = 0;\n    updateExtractionState({\n        phase: 'twitter_api_fetch',\n        startTime: Date.now(),\n        message: isDeltaSync ? 'Delta sync: Checking for new bookmarks...' : 'Full sync: Extracting all bookmarks...',\n        bookmarkCount: 0,\n        isBackground: extractionState.isBackground\n    });\n    try {\n        // Get CSRF token (keep existing logic)\n        console.log('üîë Getting CSRF token...');\n        const csrfToken = await getCsrfToken();\n        let hasMore = true;\n        let consecutiveEmptyBatches = 0;\n        while (hasMore && consecutiveEmptyBatches < 3) {\n            try {\n                console.log(`üì• Fetching batch ${Math.floor(allExtractedBookmarks.length / 100) + 1}...`);\n                // Use existing fetcher logic\n                const { bookmarks, nextCursor } = await fetchBookmarksV2(cursor, csrfToken, isDeltaSync);\n                if (bookmarks.length === 0) {\n                    consecutiveEmptyBatches++;\n                    console.log(`‚ö†Ô∏è Empty batch ${consecutiveEmptyBatches}/3`);\n                }\n                else {\n                    consecutiveEmptyBatches = 0;\n                }\n                // Process bookmarks in batches\n                updateExtractionState({\n                    phase: 'indexeddb_save',\n                    message: `Processing ${bookmarks.length} bookmarks...`\n                });\n                for (const bookmark of bookmarks) {\n                    // Check for delta sync termination\n                    if (isDeltaSync && lastBookmarkId && bookmark.id === lastBookmarkId) {\n                        console.log('üéØ Delta sync: Reached last known bookmark, stopping');\n                        hasMore = false;\n                        break;\n                    }\n                    // Save to IndexedDB instead of server\n                    await saveBookmarkToLocal(bookmark);\n                    allExtractedBookmarks.push(bookmark);\n                    // Update newest bookmark ID\n                    if (!newestBookmarkId) {\n                        newestBookmarkId = bookmark.id;\n                    }\n                }\n                // Update cursor and continue\n                cursor = nextCursor;\n                hasMore = !!nextCursor && consecutiveEmptyBatches < 3;\n                // Rate limiting (keep existing logic)\n                requestsLeft--;\n                if (requestsLeft <= 0) {\n                    console.log('‚è∏Ô∏è Rate limit reached, stopping extraction');\n                    break;\n                }\n                // Delay between requests\n                if (hasMore) {\n                    await delay(RATE_LIMIT_DELAY);\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Error in extraction batch:', error);\n                if (error instanceof RateLimitError) {\n                    console.log('‚è∏Ô∏è Rate limited, stopping extraction');\n                    break;\n                }\n                retryCount++;\n                if (retryCount >= MAX_RETRIES) {\n                    console.error('‚ùå Max retries reached, stopping extraction');\n                    break;\n                }\n                await delay(RATE_LIMIT_DELAY * retryCount);\n            }\n        }\n        // Update sync state (keep existing logic)\n        if (newestBookmarkId) {\n            lastBookmarkId = newestBookmarkId;\n            lastSyncTimestamp = Date.now();\n            chrome.storage.local.set({\n                lastBookmarkId,\n                lastSyncTimestamp,\n                requestsLeft,\n                syncType: isDeltaSync ? 'delta' : 'full'\n            });\n        }\n        updateExtractionState({\n            phase: 'idle',\n            message: `‚úÖ Extraction complete! Processed ${allExtractedBookmarks.length} bookmarks`,\n            percentage: 100\n        });\n        console.log(`üéâ Extraction complete: ${allExtractedBookmarks.length} bookmarks saved to IndexedDB`);\n    }\n    catch (error) {\n        console.error('‚ùå Extraction failed:', error);\n        updateExtractionState({\n            phase: 'idle',\n            message: `‚ùå Extraction failed: ${error.message}`,\n            percentage: 0\n        });\n    }\n    finally {\n        isExtracting = false;\n        // Schedule next fetch (keep existing logic)\n        serviceWorker.scheduleNextFetch();\n    }\n};\n// ===============================\n// MESSAGE HANDLING (Enhanced with search)\n// ===============================\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log(\"Enhanced Service Worker received message:\", request);\n    switch (request.action) {\n        case \"startExtraction\":\n            handleStartExtraction(sendResponse, request.options);\n            return true;\n        case \"searchBookmarks\":\n            handleSearchBookmarks(request.query, sendResponse);\n            return true;\n        case \"saveBookmark\":\n            handleSaveBookmark(request.bookmark, sendResponse);\n            return true;\n        case \"getProgress\":\n            sendResponse({\n                isExtracting,\n                bookmarkCount: extractionState.bookmarkCount,\n                totalBookmarks: estimatedTotalBookmarks || extractionState.bookmarkCount,\n                extractionState: extractionState,\n                canStartExtraction: !isExtracting\n            });\n            break;\n        case \"getStats\":\n            handleGetStats(sendResponse);\n            return true;\n        case \"getState\":\n            handleGetState(sendResponse);\n            return true;\n    }\n});\nconst handleStartExtraction = async (sendResponse, options = {}) => {\n    try {\n        await serviceWorker.initialize();\n        const isLoggedIn = await serviceWorker.checkXLoginStatus();\n        if (isLoggedIn) {\n            // Update extraction options\n            extractionState.isBackground = options.isBackground || false;\n            await extractAllBookmarks();\n            sendResponse({ success: true, status: \"started\" });\n        }\n        else {\n            sendResponse({ success: false, error: \"X.com login required\" });\n        }\n    }\n    catch (error) {\n        console.error('Error starting extraction:', error);\n        sendResponse({ success: false, error: error.message });\n    }\n};\nconst handleSearchBookmarks = async (query, sendResponse) => {\n    try {\n        await serviceWorker.initialize();\n        if (serviceWorker.searchEngine) {\n            const result = await serviceWorker.searchEngine.search(query);\n            sendResponse({ success: true, result });\n        }\n        else {\n            // Fallback to chrome.storage.local search for testing\n            console.log('üîç Using fallback search (testing mode)');\n            const result = await chrome.storage.local.get(null);\n            const bookmarks = Object.keys(result)\n                .filter(key => key.startsWith('bookmark_'))\n                .map(key => result[key])\n                .filter(bookmark => {\n                if (query.text) {\n                    return bookmark.text.toLowerCase().includes(query.text.toLowerCase());\n                }\n                if (query.tags && query.tags.length > 0) {\n                    return query.tags.some(tag => bookmark.tags.includes(tag));\n                }\n                return true;\n            })\n                .slice(0, query.limit || 50);\n            sendResponse({ success: true, result: { results: bookmarks, totalFound: bookmarks.length } });\n        }\n    }\n    catch (error) {\n        console.error('Search error:', error);\n        sendResponse({ success: false, error: error.message });\n    }\n};\nconst handleSaveBookmark = async (bookmark, sendResponse) => {\n    try {\n        const saved = await saveBookmarkToLocal(bookmark, bookmark.tags);\n        sendResponse({ success: !!saved, bookmark: saved });\n    }\n    catch (error) {\n        console.error('Save bookmark error:', error);\n        sendResponse({ success: false, error: error.message });\n    }\n};\nconst handleGetState = async (sendResponse) => {\n    try {\n        await serviceWorker.initialize();\n        sendResponse({\n            success: true,\n            state: {\n                isRunning: isExtracting,\n                nextRun: lastSyncTimestamp ? new Date(lastSyncTimestamp + (currentScheduleInterval * 60 * 1000)).toISOString() : null,\n                error: null,\n                phase: extractionState.phase,\n                bookmarkCount: extractionState.bookmarkCount,\n                percentage: extractionState.percentage\n            }\n        });\n    }\n    catch (error) {\n        console.error('Error getting state:', error);\n        sendResponse({\n            success: false,\n            error: error.message\n        });\n    }\n};\nconst handleGetStats = async (sendResponse) => {\n    try {\n        await serviceWorker.initialize();\n        if (serviceWorker.db && serviceWorker.searchEngine) {\n            // Get statistics from IndexedDB\n            const stats = await serviceWorker.db.getStats();\n            const searchStats = serviceWorker.searchEngine.getCacheStats();\n            sendResponse({\n                success: true,\n                stats: {\n                    totalBookmarks: stats.data?.totalBookmarks || 0,\n                    totalTags: stats.data?.uniqueTags || 0,\n                    storageUsed: stats.data?.storageSize || 0,\n                    searchCache: searchStats,\n                    lastSync: lastSyncTimestamp,\n                    syncMode: isDeltaSync ? 'delta' : 'full'\n                }\n            });\n        }\n        else {\n            // Fallback to chrome.storage.local stats for testing\n            console.log('üìä Using fallback stats (testing mode)');\n            const result = await chrome.storage.local.get(null);\n            const bookmarkCount = Object.keys(result).filter(key => key.startsWith('bookmark_')).length;\n            sendResponse({\n                success: true,\n                stats: {\n                    totalBookmarks: bookmarkCount,\n                    totalTags: 0,\n                    storageUsed: 0,\n                    searchCache: { size: 0, hits: 0, misses: 0 },\n                    lastSync: lastSyncTimestamp,\n                    syncMode: isDeltaSync ? 'delta' : 'full'\n                }\n            });\n        }\n    }\n    catch (error) {\n        console.error('Get stats error:', error);\n        sendResponse({ success: false, error: error.message });\n    }\n};\n// ===============================\n// UTILITY FUNCTIONS (Keep + enhance)\n// ===============================\nconst tokenizeText = (text) => {\n    if (!text)\n        return [];\n    return text\n        .toLowerCase()\n        .replace(/[^\\w\\s]/g, ' ')\n        .split(/\\s+/)\n        .filter(token => token.length >= 3)\n        .slice(0, 10);\n};\nconst updateExtractionState = (updates) => {\n    extractionState = { ...extractionState, ...updates };\n    console.log(`üìä State updated:`, extractionState);\n    broadcastStateUpdate();\n};\nconst broadcastStateUpdate = () => {\n    const stateMessage = {\n        action: \"stateUpdate\",\n        extractionState: extractionState,\n        isExtracting: isExtracting\n    };\n    // Notify content scripts\n    chrome.tabs.query({ url: \"https://x.com/*\" }, (tabs) => {\n        tabs.forEach(tab => {\n            notifyContentScript(tab.id, stateMessage).catch(() => { });\n        });\n    });\n    // Notify popup\n    notifyPopup(stateMessage);\n};\n// ===============================\n// INITIALIZATION\n// ===============================\nconst serviceWorker = new ExtensionServiceWorker();\n// Initialize on startup\nchrome.runtime.onStartup.addListener(() => {\n    console.log('üöÄ Extension startup - initializing service worker');\n    serviceWorker.initialize();\n});\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('üöÄ Extension installed - initializing service worker');\n    serviceWorker.initialize();\n});\n// Keep existing alarm and activity tracking\n// (Additional existing background.js logic will be adapted in subsequent files)\n// User activity tracking (keep from background.js)\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    if (changeInfo.status === 'complete' && tab.url && tab.url.includes('x.com')) {\n        lastUserActivity = Date.now();\n        console.log('üë§ User activity detected on X.com');\n        // Update schedule interval based on activity\n        serviceWorker.updateScheduleInterval();\n    }\n});\nchrome.tabs.onActivated.addListener((activeInfo) => {\n    chrome.tabs.get(activeInfo.tabId, (tab) => {\n        if (tab.url && tab.url.includes('x.com')) {\n            lastUserActivity = Date.now();\n            serviceWorker.updateScheduleInterval();\n        }\n    });\n});\nconsole.log('üì° Enhanced Service Worker loaded - ready for initialization');\n// Export for testing in Service Worker environment\nif (typeof self !== 'undefined') {\n    self.testXSaved = {\n        extractionState,\n        serviceWorker,\n        verifyDatabase: async () => {\n            if (serviceWorker.db) {\n                await serviceWorker.db.verifyDatabase();\n            }\n            else {\n                console.error('‚ùå Database not initialized');\n            }\n        },\n        getStats: async () => {\n            if (serviceWorker.db) {\n                const stats = await serviceWorker.db.getStats();\n                console.log('üìä Database stats:', stats);\n                return stats;\n            }\n            else {\n                console.error('‚ùå Database not initialized');\n            }\n        },\n        // === COMPREHENSIVE IndexedDB DEBUGGING ===\n        inspectDB: async () => {\n            console.log('üîç === IndexedDB Inspection ===');\n            if (!serviceWorker.db) {\n                console.error('‚ùå Database not initialized');\n                return;\n            }\n            try {\n                // Database info\n                console.log('üìä Database Info:', {\n                    name: serviceWorker.db.db?.name,\n                    version: serviceWorker.db.db?.version,\n                    initialized: serviceWorker.db.isInitialized,\n                    objectStores: serviceWorker.db.db ? Array.from(serviceWorker.db.db.objectStoreNames) : 'N/A'\n                });\n                // Test connection\n                const testResult = await serviceWorker.db.getStats();\n                console.log('‚úÖ Database connection: OK');\n                console.log('üìà Current stats:', testResult);\n            }\n            catch (error) {\n                console.error('‚ùå Database inspection failed:', error);\n            }\n        },\n        listBookmarks: async (limit = 10) => {\n            console.log(`üîç === Last ${limit} Bookmarks ===`);\n            if (!serviceWorker.db) {\n                console.error('‚ùå Database not initialized');\n                return;\n            }\n            try {\n                const result = await serviceWorker.db.getAllBookmarks({ limit, sortBy: 'created_at', sortOrder: 'desc' });\n                if (result.success) {\n                    console.table(result.data?.map(b => ({\n                        id: b.id,\n                        text: b.text.substring(0, 50) + '...',\n                        author: b.author,\n                        created_at: b.created_at,\n                        tags: b.tags?.join(', ') || 'none'\n                    })));\n                    return result.data;\n                }\n                else {\n                    console.error('‚ùå Failed to list bookmarks:', result.error);\n                }\n            }\n            catch (error) {\n                console.error('‚ùå List bookmarks error:', error);\n            }\n        },\n        testBookmarkCRUD: async () => {\n            console.log('üß™ === Testing Bookmark CRUD Operations ===');\n            if (!serviceWorker.db) {\n                console.error('‚ùå Database not initialized');\n                return;\n            }\n            const testBookmark = {\n                id: 'test_crud_' + Date.now(),\n                text: 'Test bookmark for CRUD operations',\n                author: 'test_user',\n                created_at: new Date().toISOString(),\n                bookmark_timestamp: new Date().toISOString(),\n                tags: ['test', 'crud'],\n                media_urls: [],\n                textTokens: ['test', 'bookmark', 'crud', 'operations']\n            };\n            try {\n                // CREATE\n                console.log('üìù Testing CREATE...');\n                const addResult = await serviceWorker.db.addBookmark(testBookmark);\n                if (!addResult.success) {\n                    console.error('‚ùå CREATE failed:', addResult.error);\n                    return false;\n                }\n                console.log('‚úÖ CREATE: Success');\n                // READ\n                console.log('üìñ Testing READ...');\n                const getResult = await serviceWorker.db.getBookmark(testBookmark.id);\n                if (!getResult.success || !getResult.data) {\n                    console.error('‚ùå READ failed:', getResult.error);\n                    return false;\n                }\n                console.log('‚úÖ READ: Success');\n                // UPDATE\n                console.log('‚úèÔ∏è Testing UPDATE...');\n                const updatedBookmark = { ...testBookmark, text: 'Updated test bookmark' };\n                const updateResult = await serviceWorker.db.updateBookmark(testBookmark.id, updatedBookmark);\n                if (!updateResult.success) {\n                    console.error('‚ùå UPDATE failed:', updateResult.error);\n                    return false;\n                }\n                console.log('‚úÖ UPDATE: Success');\n                // DELETE\n                console.log('üóëÔ∏è Testing DELETE...');\n                const deleteResult = await serviceWorker.db.deleteBookmark(testBookmark.id);\n                if (!deleteResult.success) {\n                    console.error('‚ùå DELETE failed:', deleteResult.error);\n                    return false;\n                }\n                console.log('‚úÖ DELETE: Success');\n                console.log('üéâ All CRUD operations passed!');\n                return true;\n            }\n            catch (error) {\n                console.error('‚ùå CRUD test failed with exception:', error);\n                return false;\n            }\n        },\n        checkIndexes: async () => {\n            console.log('üîç === Checking IndexedDB Indexes ===');\n            if (!serviceWorker.db?.db) {\n                console.error('‚ùå Database not available');\n                return;\n            }\n            try {\n                const db = serviceWorker.db.db;\n                const storeNames = Array.from(db.objectStoreNames);\n                for (const storeName of storeNames) {\n                    console.log(`üì¶ Store: ${storeName}`);\n                    // Create a read transaction to inspect the store\n                    const transaction = db.transaction(storeName, 'readonly');\n                    const store = transaction.objectStore(storeName);\n                    console.log(`  üìã Key path: ${store.keyPath}`);\n                    console.log(`  üî¢ Auto increment: ${store.autoIncrement}`);\n                    const indexNames = Array.from(store.indexNames);\n                    console.log(`  üìö Indexes (${indexNames.length}):`);\n                    for (const indexName of indexNames) {\n                        const index = store.index(indexName);\n                        console.log(`    - ${indexName}: keyPath=${index.keyPath}, unique=${index.unique}, multiEntry=${index.multiEntry}`);\n                    }\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Index check failed:', error);\n            }\n        },\n        clearDB: async () => {\n            console.log('üóëÔ∏è === CLEARING ALL DATA ===');\n            if (!serviceWorker.db) {\n                console.error('‚ùå Database not initialized');\n                return;\n            }\n            const confirmed = confirm('‚ö†Ô∏è This will delete ALL bookmarks. Are you sure?');\n            if (!confirmed) {\n                console.log('‚ùå Operation cancelled');\n                return;\n            }\n            try {\n                const result = await serviceWorker.db.clearAllBookmarks();\n                if (result.success) {\n                    console.log('‚úÖ Database cleared successfully');\n                }\n                else {\n                    console.error('‚ùå Failed to clear database:', result.error);\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Clear database error:', error);\n            }\n        },\n        forceReinit: async () => {\n            console.log('üîÑ === FORCING DATABASE REINITIALIZATION ===');\n            try {\n                serviceWorker.initialized = false;\n                serviceWorker.db = null;\n                await serviceWorker.initialize();\n                console.log('‚úÖ Database reinitialized successfully');\n            }\n            catch (error) {\n                console.error('‚ùå Reinitialization failed:', error);\n            }\n        }\n    };\n    console.log('üîß === XSaved v2 Debug Console ===');\n    console.log('Available commands:');\n    console.log('  ‚Ä¢ self.testXSaved.inspectDB() - Database overview');\n    console.log('  ‚Ä¢ self.testXSaved.listBookmarks(10) - Show recent bookmarks');\n    console.log('  ‚Ä¢ self.testXSaved.testBookmarkCRUD() - Test all operations');\n    console.log('  ‚Ä¢ self.testXSaved.checkIndexes() - Inspect database schema');\n    console.log('  ‚Ä¢ self.testXSaved.getStats() - Get performance stats');\n    console.log('  ‚Ä¢ self.testXSaved.clearDB() - Clear all data (WARNING!)');\n    console.log('  ‚Ä¢ self.testXSaved.forceReinit() - Reinitialize database');\n    console.log('  ‚Ä¢ self.testXSaved.verifyDatabase() - Basic verification');\n}\n"],"names":[],"sourceRoot":""}