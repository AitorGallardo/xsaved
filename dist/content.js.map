{"version":3,"file":"content.js","mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAOA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAkBA;AACA;AACA;AAAA;AA6BA;AACA;AACA;AAAA;AAmCA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AASA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://xsaved-extension-v2/./src/extension/content.js"],"sourcesContent":["/**\n * XSaved Extension v2 - Content Script\n * Phase 3: Content Script & DOM Injection\n * \n * Features:\n * - Bookmark button interception with save dialog\n * - X.com /bookmarks page toggle for grid view\n * - Robust messaging with service worker\n * - Integration with Components 1 & 2 (IndexedDB + Search)\n * \n * =============================================================================\n * 📊 DATA LOADING FLOWS DOCUMENTATION\n * =============================================================================\n * \n * 🔄 **1. INITIAL LOADING SEARCH**\n * Flow: loadBookmarksGrid() → loadBookmarksPage() → Service Worker → SearchEngine\n * Trigger: User opens extension grid interface\n * Query: { limit: INITIAL_LOAD, offset: 0, sortBy: 'created_at', sortOrder: 'desc' }\n * Result: Loads first page of bookmarks with default sorting\n * \n * 📄 **2. PAGINATION SEARCH**\n * Flow: loadNextPage() → loadBookmarksPage(append=true) → Service Worker → SearchEngine\n * Trigger: User scrolls to bottom of grid\n * Query: Uses this.pagination.currentQuery + incremented offset\n * Result: Appends more results to existing grid without replacing\n * \n * 🔍 **3. TEXT SEARCH**\n * Flow: User types → updateFilter('text') → executeSearch() → loadBookmarksPage()\n * Trigger: Text input with debounce (300ms)\n * State: activeFilters = [{type: 'text', value: 'search term', label: 'search term'}]\n * Query: { text: 'search term', limit: INITIAL_LOAD, offset: 0, sortBy: current, sortOrder: current }\n * Result: Replaces grid with text search results\n * \n * 👤 **4. AUTHOR SEARCH**\n * Flow: Type '@' → Author dropdown → selectAuthor() → updateFilter('author') → executeSearch()\n * Trigger: User selects author from '@' dropdown\n * State: activeFilters = [{type: 'author', value: 'username', label: '@username', avatarUrl: '...'}]\n * Query: { author: 'username', limit: INITIAL_LOAD, offset: 0, sortBy: current, sortOrder: current }\n * Result: Replaces grid with author-specific tweets, search box shows author with avatar\n * \n * 🏷️ **5. TAG SEARCH**\n * Flow: selectActiveTag() → loadBookmarksPage() → Service Worker → SearchEngine\n * Trigger: User clicks tag filter\n * State: this.currentSelectedTags = Set(['tag1', 'tag2'])\n * Query: { tags: ['tag1', 'tag2'], limit: INITIAL_LOAD, offset: 0, sortBy: current, sortOrder: current }\n * Result: Replaces grid with tag-filtered results\n * \n * 🔄 **6. SORT SEARCH**\n * Flow: Sort button → showSortMenuWithFilters() → executeSearch() → loadBookmarksPage()\n * Trigger: User changes sort order/field\n * State: this.currentSort = {field: 'created_at', order: 'desc'}\n * Query: Combines current activeFilters + new sort settings\n * Result: Re-executes current search with new sorting, preserving all filters\n * \n * =============================================================================\n * 🔗 **UNIFIED SEARCH ARCHITECTURE**\n * =============================================================================\n * \n * **State Management:**\n * - activeFilters[] = Unified filter state (text, author, future: tags, dates)\n * - this.currentSort = Sort state shared across all searches\n * - this.pagination.currentQuery = Last executed query for pagination\n * \n * **Single Entry Point:**\n * - executeSearch() = ONLY function that builds final query and triggers search\n * - All search types → updateFilter() → executeSearch() → loadBookmarksPage()\n * \n * **Search Persistence:**\n * - Text + Author filters persist through sorting\n * - Sort settings persist through filter changes\n * - Pagination uses stored query for consistency\n * \n * **Query Building:**\n * executeSearch() reads activeFilters + this.currentSort → Builds unified query →\n * Service Worker → SearchEngine.search() → Database → Results\n */\n\nconsole.log('🚀 XSaved v2 Enhanced Content Script loaded:', window.location.href);\n\n// ===== CONFIGURATION =====\nconst XSAVED_CONFIG = {\n  selectors: {\n    bookmarkButton: '[data-testid=\"bookmark\"], [data-testid=\"removeBookmark\"]',\n    // Target the exact h2 element from the Twitter bookmarks page\n    bookmarksPageHeader: 'h2[dir=\"ltr\"][aria-level=\"2\"][role=\"heading\"]',\n    // Fallback: target the container if the specific h2 isn't found\n    bookmarksContainer: 'div.css-175oi2r.r-1habvwh',\n    tweetContainer: '[data-testid=\"tweet\"]',\n    tweetText: '[data-testid=\"tweetText\"]',\n    userAvatar: '[data-testid=\"Tweet-User-Avatar\"]',\n    userName: '[data-testid=\"User-Name\"]'\n  },\n  pages: {\n    bookmarks: '/i/bookmarks',\n    isBookmarksPage: () => window.location.pathname.includes('/i/bookmarks')\n  },\n  ui: {\n    fadeTimeout: 2000,  // 2 seconds auto-fade as requested\n    animationDuration: 300\n  }\n};\n\n// ===== STATE MANAGEMENT =====\nlet currentTooltip = null;\nlet tooltipTimeout = null;\nlet interceptedButtons = new Set();\nlet isGridModeActive = false;\nlet bookmarkButtonObserver = null;\n\n// ===== SAFE MESSAGING =====\nconst safeRuntimeMessage = (message, callback) => {\n  try {\n    chrome.runtime.sendMessage(message, (response) => {\n      if (chrome.runtime.lastError) {\n        console.log('Extension context unavailable (normal during reload/navigation)');\n        if (callback) callback(null);\n      } else {\n        if (callback) callback(response);\n      }\n    });\n  } catch (error) {\n    console.log('Extension context unavailable (normal during reload/navigation)');\n    if (callback) callback(null);\n  }\n};\n\n// ===== CONFIGURATION =====\n// Centralized limits configuration - matches limits.ts\nconst DEFAULT_BOOKMARK_LIMIT = 5000; // Default search limit (matches limits.ts)\nconst PAGINATION_CONFIG = {\n  INITIAL_LOAD: 200,        // First load: 200 bookmarks (matches limits.ts)\n  PAGE_SIZE: 200,           // Each subsequent load: 200 more bookmarks (matches limits.ts)\n  SCROLL_THRESHOLD: 0.9    // Trigger next load when 90% scrolled (matches limits.ts)\n};\n\n// ===== INITIALIZATION =====\nclass XSavedContentScript {\n  constructor() {\n    this.initialized = false;\n    this.stats = null;\n    this.themeUnsubscribe = null;\n    this.allBookmarks = []; // Store all bookmarks for filtering\n    this.currentSelectedTags = new Set(['All']); // Track current tag selection\n    this.currentGridContainer = null; // Store reference to current grid container\n    \n    // NEW: Pagination state\n    this.pagination = {\n      currentOffset: 0,           // Current pagination offset\n      hasMore: true,              // Whether more bookmarks are available\n      isLoading: false,           // Prevent multiple simultaneous loads\n      currentQuery: null,         // Store current search query for pagination\n      totalLoaded: 0              // Track total bookmarks loaded\n    };\n  }\n\n  async initialize() {\n    if (this.initialized) return;\n    \n    console.log('📀 Initializing XSaved Content Script...');\n    \n    try {\n      // Initialize theme synchronization first\n      this.initializeThemeSync();\n      \n      // Get current stats from service worker\n      await this.updateStats();\n      \n      // Set up sync state monitoring\n      this.setupSyncStateListener();\n      \n      // Initialize based on current page\n      if (XSAVED_CONFIG.pages.isBookmarksPage()) {\n        this.initializeBookmarksPage();\n      }\n      \n      // Always initialize bookmark button interception\n      this.initializeBookmarkInterception();\n      \n      // Set up navigation listener for SPA changes\n      this.setupNavigationListener();\n      \n      console.log('✅ XSaved Content Script initialized successfully');\n      this.initialized = true;\n      \n    } catch (error) {\n      console.error('❌ Content Script initialization failed:', error);\n    }\n  }\n\n  /**\n   * Initialize theme synchronization with X.com\n   */\n  initializeThemeSync() {\n    if (window.XSavedTheme) {\n      console.log('🎨 Setting up theme synchronization...');\n      \n      // Subscribe to theme changes\n      this.themeUnsubscribe = window.XSavedTheme.onThemeChange((theme) => {\n        console.log('🎨 Theme updated in content script:', theme);\n        this.onThemeChanged(theme);\n      });\n      \n      // Get current theme\n      const currentTheme = window.XSavedTheme.getCurrentTheme();\n      if (currentTheme) {\n        this.onThemeChanged(currentTheme);\n      }\n    } else {\n      console.warn('🎨 XSavedTheme not available, theme sync disabled');\n    }\n  }\n\n  /**\n   * Handle theme changes\n   */\n  onThemeChanged(theme) {\n    // Update any dynamic UI elements with new theme\n    console.log('🎨 Applying theme to XSaved UI elements:', theme.mode);\n    \n    // You can add specific theme-dependent logic here\n    // For example, adjusting overlay opacity, shadows, etc.\n    this.updateUIForTheme(theme);\n  }\n\n  /**\n   * Update UI elements for new theme\n   */\n  updateUIForTheme(theme) {\n    // Update grid overlay if it exists\n    const gridOverlay = document.getElementById('xsaved-grid-overlay');\n    if (gridOverlay) {\n      gridOverlay.setAttribute('data-theme', theme.mode);\n    }\n\n    // Update save dialog if it exists\n    const saveDialog = document.querySelector('.xsaved-save-dialog');\n    if (saveDialog) {\n      saveDialog.setAttribute('data-theme', theme.mode);\n    }\n\n    // Update bookmarks toggle if it exists\n    const bookmarksToggle = document.getElementById('xsaved-bookmarks-toggle');\n    if (bookmarksToggle) {\n      bookmarksToggle.setAttribute('data-theme', theme.mode);\n    }\n\n    // Update fixed header/navbar if it exists\n    const fixedHeader = document.getElementById('xsaved-fixed-header');\n    if (fixedHeader) {\n      fixedHeader.setAttribute('data-theme', theme.mode);\n      console.log('🎨 Updated fixed header with theme:', theme.mode);\n    }\n  }\n\n  async updateStats() {\n    return new Promise((resolve) => {\n      safeRuntimeMessage({ action: 'getStats' }, (response) => {\n        if (response?.success) {\n          this.stats = response.stats;\n          console.log('📊 Updated stats:', this.stats);\n          \n          // Update stats indicator if it exists\n          this.updateStatsIndicator();\n        } else {\n          console.warn('Failed to get stats from service worker');\n        }\n        resolve();\n      });\n    });\n  }\n\n  // ===== SYNC SPINNER MANAGEMENT =====\n  showSyncSpinner() {\n    const spinner = document.getElementById('xsaved-sync-spinner');\n    if (spinner) {\n      spinner.style.display = 'block';\n      console.log('🔄 Sync spinner shown');\n    }\n  }\n\n  hideSyncSpinner() {\n    const spinner = document.getElementById('xsaved-sync-spinner');\n    if (spinner) {\n      spinner.style.display = 'none';\n      console.log('⏹️ Sync spinner hidden');\n    }\n  }\n\n  updateStatsIndicator() {\n    const statsIndicator = document.getElementById('xsaved-stats-indicator');\n    if (statsIndicator && this.stats) {\n      statsIndicator.textContent = `${this.stats.totalBookmarks.toLocaleString()} saved`;\n    }\n  }\n\n  setupSyncStateListener() {\n    // Listen for sync state updates from the service worker\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      if (message.action === 'stateUpdate' && message.extractionState) {\n        this.handleSyncStateUpdate(message.extractionState);\n      }\n    });\n    \n    // Also periodically check sync state if on bookmarks page\n    if (XSAVED_CONFIG.pages.isBookmarksPage()) {\n      this.startSyncStateMonitoring();\n    }\n  }\n\n  handleSyncStateUpdate(extractionState) {\n    const { phase, isBackground } = extractionState;\n    \n    // Show spinner when sync is active\n    if (phase === 'twitter_api_fetch' || phase === 'indexeddb_save') {\n      this.showSyncSpinner();\n    } else if (phase === 'idle') {\n      // Hide spinner when sync completes\n      setTimeout(() => {\n        this.hideSyncSpinner();\n        // Update stats after sync completes\n        this.updateStats();\n      }, 1000);\n    }\n  }\n\n  startSyncStateMonitoring() {\n    // Check sync state every 2 seconds while on bookmarks page\n    const checkSyncState = () => {\n      if (!XSAVED_CONFIG.pages.isBookmarksPage()) {\n        return; // Stop monitoring if user navigated away\n      }\n      \n      chrome.runtime.sendMessage({ action: 'getProgress' }, (response) => {\n        if (response && response.extractionState) {\n          this.handleSyncStateUpdate(response.extractionState);\n        }\n        \n        // Continue monitoring\n        setTimeout(checkSyncState, 2000);\n      });\n    };\n    \n    // Start monitoring after a delay\n    setTimeout(checkSyncState, 2000);\n  }\n\n  // ===== BOOKMARKS PAGE FEATURES =====\n  initializeBookmarksPage() {\n    console.log('🔖 Initializing bookmarks page features...');\n    \n    // Set up mutation observer to wait for exact bookmarks content to load\n    this.setupBookmarksContentObserver();\n    \n    // Listen for bookmark data changes\n    this.setupBookmarksPageObserver();\n  }\n\n  setupBookmarksContentObserver() {\n    console.log('🔍 Setting up bookmarks content observer...');\n    \n    // Check if toggle already exists\n    if (document.getElementById('xsaved-bookmarks-toggle')) {\n      console.log('⚠️ Bookmarks toggle already exists, skipping observer setup');\n      return;\n    }\n    \n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          // Check if any added nodes contain bookmarks page structure (NOT messages drawer)\n          const hasBookmarksHeader = Array.from(mutation.addedNodes).some(node => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const element = node;\n              \n              // Look for h2 elements in the added nodes\n              const h2Elements = element.querySelectorAll ? \n                Array.from(element.querySelectorAll('h2')) : \n                (element.tagName === 'H2' ? [element] : []);\n              \n              if (h2Elements.length === 0) return false;\n              \n              // NUCLEAR PREVENTION: Only allow h2 elements that are DEFINITELY in bookmarks page\n              return h2Elements.some(h2 => {\n                console.log('🔍 STRICT VALIDATION for h2:', h2.textContent);\n                \n                // STEP 1: ABSOLUTE BLACKLIST - Messages drawer\n                const isInMessagesDrawer = h2.closest('[data-testid=\"DMDrawer\"]') || \n                                          h2.closest('[data-testid=\"DMDrawerHeader\"]');\n                \n                if (isInMessagesDrawer) {\n                  console.log('🚫 BLOCKED: h2 in messages drawer:', h2.textContent);\n                  return false;\n                }\n                \n                // STEP 2: WHITELIST VALIDATION - Must have bookmarks page indicators\n                const hasBackButton = document.querySelector('[data-testid=\"app-bar-back\"]');\n                const isInPrimaryColumn = h2.closest('[data-testid=\"primaryColumn\"]');\n                const isInMainContent = h2.closest('main') || h2.closest('[role=\"main\"]');\n                \n                // STEP 3: CONTAINER STRUCTURE VALIDATION\n                const container = h2.closest('div.css-175oi2r.r-1habvwh');\n                const containerNotInMessagesDrawer = container && !container.closest('[data-testid=\"DMDrawer\"]');\n                \n                // STEP 4: ADDITIONAL SAFETY CHECKS\n                const hasCorrectParentStructure = h2.parentElement && \n                                                 h2.parentElement.classList.contains('css-175oi2r');\n                \n                // STEP 5: FINAL VALIDATION - All conditions must be true\n                const isValid = hasBackButton && // Must have back button (bookmarks page indicator)\n                               (isInPrimaryColumn || isInMainContent) && // Must be in main content\n                               containerNotInMessagesDrawer && // Container must not be in messages drawer\n                               hasCorrectParentStructure; // Must have correct parent structure\n                \n                console.log('🔍 STRICT VALIDATION RESULTS:');\n                console.log('  - Has back button (REQUIRED):', !!hasBackButton);\n                console.log('  - In primary column:', !!isInPrimaryColumn);\n                console.log('  - In main content:', !!isInMainContent);\n                console.log('  - Container not in messages drawer:', !!containerNotInMessagesDrawer);\n                console.log('  - Has correct parent structure:', !!hasCorrectParentStructure);\n                console.log('  - FINAL RESULT:', isValid);\n                \n                if (!isValid) {\n                  console.log('🚫 BLOCKED: h2 failed strict validation:', h2.textContent);\n                }\n                \n                return isValid;\n              });\n            }\n            return false;\n          });\n          \n          if (hasBookmarksHeader && XSAVED_CONFIG.pages.isBookmarksPage()) {\n            console.log('🎯 Detected bookmarks header content, attempting toggle placement...');\n            \n            // Small delay to ensure DOM is stable\n            setTimeout(() => {\n              this.attemptBookmarksTogglePlacement();\n            }, 100);\n          }\n        }\n      });\n    });\n    \n    // Observe the entire document for changes\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    // Also try immediately in case content is already loaded\n    setTimeout(() => {\n      this.attemptBookmarksTogglePlacement();\n    }, 500);\n    \n    // Clean up observer after 30 seconds to avoid memory leaks\n    setTimeout(() => {\n      observer.disconnect();\n      console.log('🧹 Cleaned up bookmarks content observer');\n    }, 30000);\n  }\n\n  attemptBookmarksTogglePlacement() {\n    console.log('🎯 Attempting bookmarks toggle placement...');\n    \n    // Check if toggle already exists\n    if (document.getElementById('xsaved-bookmarks-toggle')) {\n      console.log('⚠️ Toggle already exists, skipping placement');\n      return;\n    }\n    \n    // Try to find the exact bookmarks page structure\n    const bookmarksHeader = this.findBookmarksHeader();\n    \n    if (bookmarksHeader.header && bookmarksHeader.container) {\n      console.log('✅ Found proper bookmarks structure, placing toggle...');\n      this.placeBookmarksToggle(bookmarksHeader.header, bookmarksHeader.container);\n    } else {\n      console.log('⏳ Bookmarks structure not ready yet, will retry...');\n    }\n  }\n\n  findBookmarksHeader() {\n    console.log('🔍 Searching for bookmarks header using structural selectors...');\n    \n    // Strategy 1: Look for h2 with back button (most reliable indicator of bookmarks page)\n    const backButton = document.querySelector('[data-testid=\"app-bar-back\"]');\n    if (backButton) {\n      console.log('✅ Found back button, looking for nearby h2...');\n      \n      // Find h2 in the same container structure as the back button\n      const h2WithBackButton = backButton.closest('div').querySelector('h2');\n      if (h2WithBackButton) {\n        // NUCLEAR SAFETY: Triple-check it's NOT in messages drawer\n        const isInMessagesDrawer = h2WithBackButton.closest('[data-testid=\"DMDrawer\"]') ||\n                                  h2WithBackButton.closest('[data-testid=\"DMDrawerHeader\"]');\n        \n        if (!isInMessagesDrawer) {\n          console.log('✅ VALIDATED: Found bookmarks header via back button:', h2WithBackButton.textContent);\n          console.log('✅ Header path:', this.getElementPath(h2WithBackButton));\n          \n          const container = this.findProperContainer(h2WithBackButton);\n          if (container) {\n            return { header: h2WithBackButton, container };\n          } else {\n            console.log('🚫 Container validation failed for back button header');\n          }\n        } else {\n          console.log('🚫 BLOCKED: Back button h2 is in messages drawer!');\n        }\n      }\n    }\n    \n    // Strategy 2: Look for h2 in primary column that's NOT in messages drawer\n    const primaryColumn = document.querySelector('[data-testid=\"primaryColumn\"]');\n    if (primaryColumn) {\n      const headers = primaryColumn.querySelectorAll('h2');\n      for (const h2 of headers) {\n        console.log('🔍 Checking h2 in primaryColumn:', h2.textContent);\n        \n        // Exclude messages drawer\n        const isInMessagesDrawer = h2.closest('[data-testid=\"DMDrawer\"]') || \n                                  h2.closest('[data-testid=\"DMDrawerHeader\"]');\n        \n        if (!isInMessagesDrawer) {\n          // Check if it's in the correct container structure\n          const isInCorrectContainer = h2.closest('div.css-175oi2r.r-1habvwh');\n          \n          if (isInCorrectContainer) {\n            console.log('✅ Found bookmarks header in primary column:', h2.textContent);\n            const container = this.findProperContainer(h2);\n            return { header: h2, container };\n          }\n        } else {\n          console.log('🚫 Skipping h2 in messages drawer:', h2.textContent);\n        }\n      }\n    }\n    \n    // Strategy 3: Look for h2 in main content areas, excluding messages drawer\n    const mainContentSelectors = ['main', '[role=\"main\"]'];\n    for (const selector of mainContentSelectors) {\n      const mainContent = document.querySelector(selector);\n      if (mainContent) {\n        const headers = mainContent.querySelectorAll('h2');\n        for (const h2 of headers) {\n          console.log('🔍 Checking h2 in main content:', h2.textContent);\n          \n          // Exclude messages drawer\n          const isInMessagesDrawer = h2.closest('[data-testid=\"DMDrawer\"]') || \n                                    h2.closest('[data-testid=\"DMDrawerHeader\"]');\n          \n          if (!isInMessagesDrawer) {\n            // Check if it's in the correct container structure\n            const isInCorrectContainer = h2.closest('div.css-175oi2r.r-1habvwh');\n            \n            if (isInCorrectContainer) {\n              console.log('✅ Found bookmarks header in main content:', h2.textContent);\n              const container = this.findProperContainer(h2);\n              return { header: h2, container };\n            }\n          } else {\n            console.log('🚫 Skipping h2 in messages drawer:', h2.textContent);\n          }\n        }\n      }\n    }\n    \n    console.log('❌ No suitable bookmarks header found');\n    console.log('🔍 Available h2 elements:');\n    document.querySelectorAll('h2').forEach((h2, index) => {\n      const isInMessagesDrawer = h2.closest('[data-testid=\"DMDrawer\"]');\n      console.log(`  ${index + 1}: \"${h2.textContent}\" (Messages drawer: ${!!isInMessagesDrawer})`);\n    });\n    \n    return { header: null, container: null };\n  }\n\n  findProperContainer(header) {\n    console.log('🔍 Finding proper container for header:', header.textContent);\n    \n    // CRITICAL: Ensure we're not in messages drawer\n    const isInMessagesDrawer = header.closest('[data-testid=\"DMDrawer\"]') || \n                              header.closest('[data-testid=\"DMDrawerHeader\"]');\n    \n    if (isInMessagesDrawer) {\n      console.log('🚫 Header is in messages drawer, aborting container search');\n      return null;\n    }\n    \n    // Strategy 1: Find the immediate parent container with the specific CSS classes\n    // This is the div that directly contains the h2 and where we want to place the toggle\n    let container = header.closest('div.css-175oi2r.r-1habvwh');\n    if (container) {\n      // Double-check this container is not in messages drawer\n      const containerInMessagesDrawer = container.closest('[data-testid=\"DMDrawer\"]');\n      if (!containerInMessagesDrawer) {\n        console.log('📍 Found direct parent container with CSS classes (verified not in messages drawer)');\n        console.log('📍 Container classes:', container.className);\n        console.log('📍 Container contains h2:', !!container.querySelector('h2'));\n        return container;\n      } else {\n        console.log('🚫 Container is in messages drawer, skipping');\n      }\n    }\n    \n    // Strategy 2: Look for parent element that can be styled with flexbox\n    container = header.parentElement;\n    if (container && container.tagName === 'DIV') {\n      const containerInMessagesDrawer = container.closest('[data-testid=\"DMDrawer\"]');\n      if (!containerInMessagesDrawer) {\n        console.log('📍 Using direct parent div container (verified not in messages drawer)');\n        console.log('📍 Parent container classes:', container.className);\n        return container;\n      } else {\n        console.log('🚫 Parent container is in messages drawer, skipping');\n      }\n    }\n    \n    // Strategy 3: Fallback to primaryColumn (less ideal as it's too broad)\n    container = header.closest('[data-testid=\"primaryColumn\"]');\n    if (container) {\n      console.log('⚠️ Using broad primaryColumn container (fallback)');\n      return container;\n    }\n    \n    // Strategy 4: Last resort - main content area\n    container = header.closest('main');\n    if (container) {\n      console.log('⚠️ Using main container (last resort)');\n      return container;\n    }\n    \n    // Final fallback\n    console.log('⚠️ Using header parent element as final fallback');\n    return header.parentElement;\n  }\n\n  placeBookmarksToggle(header, container) {\n    console.log('🎯 Attempting to place toggle next to header:', header.textContent);\n    \n    // ABSOLUTE PREVENTION: Triple-check we're not in messages drawer\n    const isHeaderInMessagesDrawer = header.closest('[data-testid=\"DMDrawer\"]') || \n                                    header.closest('[data-testid=\"DMDrawerHeader\"]');\n    \n    const isContainerInMessagesDrawer = container.closest('[data-testid=\"DMDrawer\"]') || \n                                       container.closest('[data-testid=\"DMDrawerHeader\"]');\n    \n    if (isHeaderInMessagesDrawer || isContainerInMessagesDrawer) {\n      console.error('🚫 BLOCKED: Attempted to place toggle in messages drawer!');\n      console.error('🚫 Header in messages drawer:', isHeaderInMessagesDrawer);\n      console.error('🚫 Container in messages drawer:', isContainerInMessagesDrawer);\n      console.error('🚫 Header path:', this.getElementPath(header));\n      console.error('🚫 Container path:', this.getElementPath(container));\n      return; // ABORT COMPLETELY\n    }\n    \n    // WHITELIST VALIDATION: Only allow placement in verified bookmarks page structure\n    const hasBackButton = document.querySelector('[data-testid=\"app-bar-back\"]');\n    const isInPrimaryColumn = header.closest('[data-testid=\"primaryColumn\"]');\n    \n    if (!hasBackButton && !isInPrimaryColumn) {\n      console.error('🚫 BLOCKED: No back button and not in primary column - not bookmarks page!');\n      return; // ABORT COMPLETELY\n    }\n    \n    // FINAL VALIDATION: Check container structure\n    const containerHasCorrectStructure = container.classList.contains('css-175oi2r') && \n                                        container.classList.contains('r-1habvwh');\n    \n    if (!containerHasCorrectStructure) {\n      console.error('🚫 BLOCKED: Container does not have correct CSS structure!');\n      console.error('🚫 Container classes:', container.className);\n      return; // ABORT COMPLETELY\n    }\n    \n    console.log('✅ VALIDATED: Safe to place toggle');\n    console.log('✅ Header path:', this.getElementPath(header));\n    console.log('✅ Container path:', this.getElementPath(container));\n    \n    // Create toggle container\n    const toggleContainer = document.createElement('div');\n    toggleContainer.id = 'xsaved-bookmarks-toggle';\n    toggleContainer.style.cssText = `\n      display: contents;\n      align-items: center;\n      gap: 12px;\n      margin-left: 16px;\n      padding: 6px 12px;\n      background: rgba(29, 161, 242, 0.1);\n      border: 1px solid rgba(29, 161, 242, 0.3);\n      border-radius: 18px;\n      font-size: 13px;\n      font-weight: 500;\n      color: rgb(29, 161, 242);\n      transition: all 0.2s ease;\n      vertical-align: middle;\n      position: relative;\n      z-index: 1000;\n    `;\n    \n    // Create toggle switch\n    const toggleSwitch = document.createElement('label');\n    toggleSwitch.style.cssText = `\n      position: relative;\n      display: inline-block;\n      width: 48px;\n      height: 26px;\n      cursor: pointer;\n    `;\n    \n    const toggleInput = document.createElement('input');\n    toggleInput.type = 'checkbox';\n    toggleInput.style.cssText = `\n      opacity: 0;\n      width: 0;\n      height: 0;\n    `;\n    toggleInput.checked = false;\n    \n    const toggleSlider = document.createElement('span');\n    toggleSlider.style.cssText = `\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      background-color: #ccc;\n      border-radius: 26px;\n      transition: background-color 0.2s ease;\n      box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.1);\n    `;\n    \n    const toggleDot = document.createElement('span');\n    toggleDot.style.cssText = `\n      position: absolute;\n      height: 20px;\n      width: 20px;\n      left: 3px;\n      top: 3px;\n      background-color: white;\n      border-radius: 50%;\n      transition: left 0.2s ease;\n      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n    `;\n    \n    toggleSwitch.appendChild(toggleInput);\n    toggleSwitch.appendChild(toggleSlider);\n    toggleSlider.appendChild(toggleDot);\n    \n    // Create stats indicator (bookmark count)\n    const statsIndicator = document.createElement('span');\n    statsIndicator.id = 'xsaved-stats-indicator';\n    statsIndicator.style.cssText = `\n      background: rgba(29, 161, 242, 0.2);\n      padding: 4px 10px;\n      border-radius: 12px;\n      font-size: 13px;\n      font-weight: 600;\n      color: rgb(29, 161, 242);\n    `;\n    statsIndicator.textContent = this.stats ? `${this.stats.totalBookmarks} saved` : 'Loading...';\n    \n    // Create sync spinner\n    const syncSpinner = document.createElement('div');\n    syncSpinner.id = 'xsaved-sync-spinner';\n    syncSpinner.style.cssText = `\n      width: 16px;\n      height: 16px;\n      border: 2px solid rgba(29, 161, 242, 0.2);\n      border-top: 2px solid rgb(29, 161, 242);\n      border-radius: 50%;\n      animation: xsaved-spin 1s linear infinite;\n      display: none;\n      margin-left: 8px;\n    `;\n    \n    // Add spinner animation CSS\n    if (!document.getElementById('xsaved-spinner-styles')) {\n      const spinnerStyles = document.createElement('style');\n      spinnerStyles.id = 'xsaved-spinner-styles';\n      spinnerStyles.textContent = `\n        @keyframes xsaved-spin {\n          0% { transform: rotate(0deg); }\n          100% { transform: rotate(360deg); }\n        }\n      `;\n      document.head.appendChild(spinnerStyles);\n    }\n    \n    // Add toggle event - IMMEDIATE ANIMATION (no waiting for grid load)\n    toggleInput.addEventListener('change', (e) => {\n      const isActive = e.target.checked;\n      \n      // IMMEDIATE animation update - no lag\n      toggleSlider.style.backgroundColor = isActive ? '#1DA1F2' : '#ccc';\n      toggleDot.style.left = isActive ? '25px' : '3px';\n      \n      // Trigger grid mode asynchronously (don't wait for it)\n      if (isActive) {\n        // Show grid mode but don't block the toggle animation\n        setTimeout(() => {\n          this.showGridInterface();\n        }, 0); // Immediate but async\n      } else {\n        this.hideGridInterface();\n      }\n    });\n    \n    // Assemble toggle (no text labels, just toggle + count + spinner)\n    toggleContainer.appendChild(toggleSwitch);\n    toggleContainer.appendChild(statsIndicator);\n    toggleContainer.appendChild(syncSpinner);\n    \n    // Style the container to use flexbox layout\n    container.style.cssText = `\n      display: flex;\n      align-items: center;\n      flex-direction: row;\n      gap: 16px;\n    `;\n    \n    // Insert toggle inside the container, right after the h2 header\n    header.style.display = 'inline-block';\n    header.insertAdjacentElement('afterend', toggleContainer);\n    \n    console.log('✅ Successfully placed bookmarks toggle');\n  }\n\n  getElementPath(element) {\n    const path = [];\n    let current = element;\n    \n    while (current && current !== document.body) {\n      let selector = current.tagName.toLowerCase();\n      \n      if (current.id) {\n        selector += `#${current.id}`;\n      }\n      \n      if (current.className) {\n        const classes = current.className.split(' ').slice(0, 3); // First 3 classes only\n        selector += '.' + classes.join('.');\n      }\n      \n      if (current.hasAttribute('data-testid')) {\n        selector += `[data-testid=\"${current.getAttribute('data-testid')}\"]`;\n      }\n      \n      path.unshift(selector);\n      current = current.parentElement;\n    }\n    \n    return path.join(' > ');\n  }\n\n  async waitForBookmarksPageLoad() {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 20; // Increased to 10 seconds (20 * 500ms)\n      \n      const checkForContent = () => {\n        attempts++;\n        \n        // Multiple strategies to detect bookmarks page content\n        const strategies = [\n          // Strategy 1: Look for specific h2 with bookmarks text\n          () => {\n            const headers = document.querySelectorAll('h2[dir=\"ltr\"]');\n            return Array.from(headers).find(h => \n              h.textContent && h.textContent.toLowerCase().includes('bookmark')\n            );\n          },\n          // Strategy 2: Look for the container we know should exist\n          () => {\n            const container = document.querySelector('div.css-175oi2r.r-1habvwh');\n            if (container) {\n              const h2 = container.querySelector('h2');\n              return h2 && h2.textContent && h2.textContent.toLowerCase().includes('bookmark') ? h2 : null;\n            }\n            return null;\n          },\n          // Strategy 3: Look for any h2 that might be the bookmarks header\n          () => {\n            const headers = document.querySelectorAll('h2');\n            return Array.from(headers).find(h => {\n              const text = h.textContent ? h.textContent.toLowerCase() : '';\n              return text.includes('bookmark') || text.includes('saved') || text === 'bookmarks';\n            });\n          },\n          // Strategy 4: Look for any content that indicates bookmarks page is loading\n          () => {\n            const currentUrl = window.location.pathname;\n            if (currentUrl.includes('/bookmarks') || currentUrl.includes('/i/bookmarks')) {\n              // Only proceed if we can find some bookmarks-specific content, not just any main element\n              const bookmarksContent = document.querySelector('[data-testid=\"primaryColumn\"] h2') ||\n                                     document.querySelector('main h2') ||\n                                     document.querySelector('[role=\"main\"] h2');\n              return bookmarksContent;\n            }\n            return null;\n          }\n        ];\n        \n        let foundHeader = null;\n        for (const strategy of strategies) {\n          foundHeader = strategy();\n          if (foundHeader) {\n            console.log(`✅ Bookmarks page content detected using strategy, proceeding with toggle placement`);\n            console.log('📍 Found header text:', foundHeader.textContent || 'URL-based detection');\n            resolve();\n            return;\n          }\n        }\n        \n        if (attempts >= maxAttempts) {\n          console.warn(`⚠️ Bookmarks page content detection timed out after ${maxAttempts} attempts.`);\n          reject(new Error('Bookmarks page content not detected'));\n          return;\n        }\n        \n        console.log(`⏳ Waiting for bookmarks page content to load... (attempt ${attempts}/${maxAttempts})`);\n        setTimeout(checkForContent, 500);\n      };\n      \n      checkForContent();\n    });\n  }\n\n\n\n  tryAlternativeTogglePlacement() {\n    console.log('🔧 Trying alternative toggle placement strategies...');\n    \n    // Strategy 1: Try to find any main content area\n    const mainContent = document.querySelector('main') || \n                       document.querySelector('[data-testid=\"primaryColumn\"]') ||\n                       document.querySelector('[role=\"main\"]');\n    \n    if (mainContent) {\n      console.log('📍 Found main content area, attempting placement...');\n      \n      // Create a simple toggle container\n      const toggleContainer = document.createElement('div');\n      toggleContainer.id = 'xsaved-bookmarks-toggle';\n      toggleContainer.style.cssText = `\n        position: fixed;\n        top: 20px;\n        right: 20px;\n        z-index: 10000;\n        display: inline-flex;\n        align-items: center;\n        gap: 8px;\n        padding: 8px 16px;\n        background: rgba(29, 161, 242, 0.9);\n        border: 1px solid rgba(29, 161, 242, 1);\n        border-radius: 20px;\n        font-size: 14px;\n        font-weight: 500;\n        color: white;\n        cursor: pointer;\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n      `;\n      \n      // Create toggle switch\n      const toggleSwitch = document.createElement('label');\n      toggleSwitch.style.cssText = `\n        position: relative;\n        display: inline-block;\n        width: 50px;\n        height: 24px;\n        cursor: pointer;\n      `;\n      \n      const toggleInput = document.createElement('input');\n      toggleInput.type = 'checkbox';\n      toggleInput.style.opacity = '0';\n      toggleInput.checked = false;\n      \n      const toggleSlider = document.createElement('span');\n      toggleSlider.style.cssText = `\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-color: #ccc;\n        border-radius: 24px;\n        transition: 0.4s;\n      `;\n      \n      const toggleDot = document.createElement('span');\n      toggleDot.style.cssText = `\n        position: absolute;\n        height: 18px;\n        width: 18px;\n        left: 3px;\n        bottom: 3px;\n        background-color: white;\n        border-radius: 50%;\n        transition: 0.4s;\n      `;\n      \n      toggleSwitch.appendChild(toggleInput);\n      toggleSwitch.appendChild(toggleSlider);\n      toggleSlider.appendChild(toggleDot);\n      \n      // Create label\n      const labelText = document.createElement('span');\n      labelText.textContent = 'XSaved Grid';\n      labelText.style.fontWeight = '600';\n      \n      // Add to container\n      toggleContainer.appendChild(labelText);\n      toggleContainer.appendChild(toggleSwitch);\n      \n      // Add to page\n      document.body.appendChild(toggleContainer);\n      \n      // Add toggle functionality\n      toggleInput.addEventListener('change', (e) => {\n        const isActive = e.target.checked;\n        labelText.textContent = isActive ? 'XSaved Grid' : 'Default View';\n        toggleSlider.style.backgroundColor = isActive ? '#1DA1F2' : '#ccc';\n        toggleDot.style.left = isActive ? '27px' : '3px';\n        this.toggleGridMode(isActive);\n      });\n      \n      console.log('✅ Successfully placed toggle using alternative strategy (fixed position)');\n      return true;\n    }\n    \n    return false;\n  }\n\n  debugDOMState() {\n    console.log('🔍 DOM Debug State:');\n    console.log('- Current URL:', window.location.href);\n    console.log('- Available h2 elements:', document.querySelectorAll('h2').length);\n    console.log('- Available containers:', document.querySelectorAll('div.css-175oi2r.r-1habvwh').length);\n    \n    const allH2s = document.querySelectorAll('h2');\n    console.log('- H2 elements found:');\n    Array.from(allH2s).forEach((h2, index) => {\n      console.log(`  ${index + 1}: \"${h2.textContent}\" (${h2.className})`);\n    });\n    \n    const containers = document.querySelectorAll('div.css-175oi2r.r-1habvwh');\n    console.log('- Containers found:');\n    Array.from(containers).forEach((container, index) => {\n      const h2InContainer = container.querySelector('h2');\n      console.log(`  ${index + 1}: Has h2: ${!!h2InContainer}, H2 text: \"${h2InContainer?.textContent || 'none'}\"`);\n    });\n  }\n\n  toggleGridMode(activate) {\n    console.log(`🔄 Toggling grid mode: ${activate ? 'ON' : 'OFF'}`);\n    \n    // Update grid state tracking\n    isGridModeActive = activate;\n    \n    // Simple immediate toggle - no waiting for content\n    if (activate) {\n      this.showGridInterface();\n    } else {\n      this.hideGridInterface();\n    }\n  }\n\n  async waitForBookmarksContent() {\n    return new Promise((resolve, reject) => {\n      let attempts = 0;\n      const maxAttempts = 10;\n      \n      const checkForContent = () => {\n        attempts++;\n        \n        // Check if bookmarks content is loaded\n        const bookmarksContent = document.querySelector('[data-testid=\"tweet\"]') ||\n                                document.querySelector('[data-testid=\"tweetText\"]') ||\n                                document.querySelector('[data-testid=\"primaryColumn\"] [data-testid=\"tweet\"]');\n        \n        if (bookmarksContent) {\n          console.log('✅ Bookmarks content is loaded, proceeding with grid mode');\n          resolve();\n          return;\n        }\n        \n        if (attempts >= maxAttempts) {\n          console.warn('⚠️ Bookmarks content detection timed out');\n          reject(new Error('Content not loaded'));\n          return;\n        }\n        \n        console.log(`⏳ Waiting for bookmarks content... (attempt ${attempts}/${maxAttempts})`);\n        setTimeout(checkForContent, 500);\n      };\n      \n      checkForContent();\n    });\n  }\n\n  showGridInterface() {\n    console.log('🏗️ Showing XSaved grid interface...');\n    \n    // Create grid overlay\n    const gridOverlay = document.createElement('div');\n    gridOverlay.id = 'xsaved-grid-overlay';\n    gridOverlay.className = 'xsaved-grid-overlay';\n    gridOverlay.style.cssText = `\n      position: fixed;\n      top: 50px;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      background: rgb(0, 0, 0);\n      z-index: 10000;\n      padding: 20px;\n      overflow-y: auto;\n    `;\n\n    // Disable scrolling on the main page\n    document.body.style.overflow = 'hidden';\n    document.documentElement.style.overflow = 'hidden';\n\n    // Hide X.com search input\n    const searchInput = document.querySelector('input[data-testid=\"SearchBox_Search_Input\"]');\n    if (searchInput) {\n      const searchContainer = searchInput.closest('div.css-175oi2r.r-1awozwy.r-aqfbo4.r-kemksi.r-18u37iz.r-1h3ijdo.r-6gpygo.r-15ysp7h.r-1xcajam.r-ipm5af.r-136ojw6.r-1hycxz');\n      if (searchContainer) {\n        searchContainer.style.display = 'none';\n        searchContainer.setAttribute('data-xsaved-hidden', 'true');\n      }\n    }\n\n    document.body.appendChild(gridOverlay);\n\n    // Render the static layout (navbar, search, tags)\n    this.renderLayout(gridOverlay);\n\n    // Load bookmarks immediately with existing data\n    this.loadBookmarksGrid(gridOverlay);\n    \n    // Trigger quick delta sync in background and refresh if new data found\n    console.log('🚀 Grid activated - starting background sync');\n    chrome.runtime.sendMessage({ action: 'quickDeltaSync' }, (response) => {\n      if (response?.success) {\n        if (response.skipped) {\n          console.log(`⏸️ Quick sync skipped: ${response.message} (${response.reason})`);\n        } else {\n          console.log('✅ Quick sync completed - checking for grid refresh');\n          // Refresh the grid to show any new data\n          this.refreshGridAfterSync();\n        }\n      } else {\n        console.log('⚠️ Quick sync failed on grid activation:', response?.error);\n      }\n    });\n  }\n\n  /**\n   * Render the static layout (navbar, search, tags, sort buttons)\n   * This creates the UI shell that persists across data updates\n   */\n  renderLayout(container) {\n    // Store container reference for filtering\n    this.currentGridContainer = container;\n    \n    // Clean up any existing fixed header to prevent sizing issues\n    const existingHeader = document.getElementById('xsaved-fixed-header');\n    if (existingHeader) {\n      existingHeader.remove();\n    }\n\n    // Create fixed header container (outside the overlay container)\n    const headerContainer = document.createElement('div');\n    headerContainer.id = 'xsaved-fixed-header';\n    headerContainer.className = 'xsaved-navbar';\n    headerContainer.style.cssText = `\n      position: fixed;\n      top: 50px;\n      left: 0;\n      right: 0;\n      z-index: 10001;\n      padding: 20px;\n    `;\n\n    // Create header with search, export, and tag filters in one row\n    const header = document.createElement('div');\n    header.style.cssText = `\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      gap: 20px;\n    `;\n\n    // TODO: TEMPORARILY DISABLED - Filters navbar (tag selectors) \n    // This feature will be re-implemented in a future version with improved UX\n    // The tag filtering system needs to be redesigned to work better with the search functionality\n    // and provide a more intuitive user experience for organizing bookmarks by categories.\n    \n    /* \n    // Left side: Tag filters\n    const tagSelector = document.createElement('div');\n    tagSelector.style.cssText = `\n      display: flex;\n      gap: 12px;\n      overflow-x: auto;\n      flex: 1;\n      scrollbar-width: none;\n      -ms-overflow-style: none;\n      padding-right: 20px;\n    `;\n    tagSelector.style.webkitScrollbar = 'none';\n\n    // Extended sample tags for scroll testing\n    const sampleTags = [\n      'All', 'Tech', 'AI', 'Programming', 'Design', 'Music', 'Gaming', 'News', \n      'Sports', 'Entertainment', 'Science', 'Business', 'Finance', 'Health', \n      'Travel', 'Food', 'Fashion', 'Art', 'Education', 'Politics', 'Environment'\n    ];\n    \n    // Track selected tags for multi-select - use class-level state\n    const selectedTags = this.currentSelectedTags;\n    \n    sampleTags.forEach(tag => {\n      const tagButton = document.createElement('button');\n      tagButton.textContent = tag;\n      tagButton.dataset.tag = tag;\n      tagButton.className = `xsaved-tag-selector ${tag === 'All' ? 'active' : ''}`;\n      tagButton.style.cssText = `\n        white-space: nowrap;\n        flex-shrink: 0;\n        position: relative;\n      `;\n\n      tagButton.addEventListener('click', () => {\n        if (tag === 'All') {\n          // If \"All\" is clicked, deselect everything else and select only \"All\"\n          selectedTags.clear();\n          selectedTags.add('All');\n          tagSelector.querySelectorAll('button').forEach(btn => {\n            btn.classList.remove('active');\n          });\n          tagButton.classList.add('active');\n        } else {\n          // Remove \"All\" from selection when other tags are selected\n          selectedTags.delete('All');\n          const allButton = tagSelector.querySelector('[data-tag=\"All\"]');\n          if (allButton) {\n            allButton.classList.remove('active');\n          }\n\n          if (selectedTags.has(tag)) {\n            // Deselect tag\n            selectedTags.delete(tag);\n            tagButton.classList.remove('active');\n          } else {\n            // Select tag\n            selectedTags.add(tag);\n            tagButton.classList.add('active');\n          }\n\n          // If no tags selected, select \"All\"\n          if (selectedTags.size === 0) {\n            selectedTags.add('All');\n            const allButton = tagSelector.querySelector('[data-tag=\"All\"]');\n            if (allButton) {\n              allButton.classList.add('active');\n            }\n          }\n        }\n        \n        console.log(`🏷️ Selected tags:`, Array.from(selectedTags));\n        \n        // Trigger bookmark filtering based on selected tags\n        this.filterBookmarksByTags(Array.from(selectedTags), this.currentGridContainer);\n      });\n\n      tagSelector.appendChild(tagButton);\n    });\n    */\n    \n    // Create placeholder for future tag filters\n    const tagSelector = document.createElement('div');\n    tagSelector.style.cssText = `\n      display: flex;\n      gap: 12px;\n      flex: 1;\n      padding-right: 20px;\n    `;\n\n    // Right side: Search and Export\n    const rightSide = document.createElement('div');\n    rightSide.style.cssText = `\n      display: flex;\n      align-items: center;\n      gap: 16px;\n      flex-shrink: 0;\n    `;\n\n    // Create search container (revert to original)\n    const searchContainer = document.createElement('div');\n    searchContainer.style.cssText = `\n      position: relative;\n      display: inline-block;\n    `;\n\n    const searchBox = document.createElement('input');\n    searchBox.type = 'text';\n    searchBox.placeholder = 'Search bookmarks... (use @ for authors)';\n    searchBox.className = 'xsaved-search-input';\n    searchBox.style.cssText = `\n      width: 300px;\n    `;\n    \n    // Create author dropdown\n    const authorDropdown = document.createElement('div');\n    authorDropdown.className = 'xsaved-author-dropdown';\n    authorDropdown.style.cssText = `\n      position: absolute;\n      top: 100%;\n      left: 0;\n      right: 0;\n      max-height: 300px;\n      background: var(--xsaved-surface-color);\n      border: 1px solid var(--xsaved-border-color);\n      border-radius: var(--xsaved-radius-medium);\n      box-shadow: var(--xsaved-shadow-heavy);\n      z-index: 10001;\n      overflow-y: auto;\n      display: none;\n    `;\n\n    searchContainer.appendChild(searchBox);\n    searchContainer.appendChild(authorDropdown);\n\n    // Sort button\n    const sortButton = document.createElement('button');\n    sortButton.innerHTML = `\n      <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <path d=\"M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z\"/>\n      </svg>\n    `;\n    sortButton.style.cssText = `\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 8px 12px;\n      background: var(--xsaved-surface-color);\n      border: 1px solid var(--xsaved-border-color);\n      border-radius: 20px;\n      color: var(--xsaved-text-color);\n      cursor: pointer;\n      transition: all 0.2s ease;\n      margin-right: 8px;\n    `;\n\n    sortButton.addEventListener('mouseenter', () => {\n      sortButton.style.background = 'var(--xsaved-hover-color)';\n    });\n    sortButton.addEventListener('mouseleave', () => {\n      sortButton.style.background = 'var(--xsaved-surface-color)';\n    });\n\n    sortButton.addEventListener('click', () => {\n      console.log('🔄 Sort button clicked');\n      this.showSortMenuWithFilters(sortButton, executeSearch);\n    });\n\n    // TODO: TEMPORARILY DISABLED - Export/Download button\n    // This feature will be re-implemented in a future version with enhanced export options\n    // The export system needs to be redesigned to support more formats, better filtering,\n    // and improved user experience for exporting bookmark collections.\n    \n    /*\n    // Download button\n    const downloadButton = document.createElement('button');\n    downloadButton.innerHTML = `\n      <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <path d=\"M12 2C13.1 2 14 2.9 14 4V12L16.5 9.5C16.9 9.1 17.5 9.1 17.9 9.5C18.3 9.9 18.3 10.5 17.9 10.9L12.7 16.1C12.3 16.5 11.7 16.5 11.3 16.1L6.1 10.9C5.7 10.5 5.7 9.9 6.1 9.5C6.5 9.1 7.1 9.1 7.5 9.5L10 12V4C10 2.9 10.9 2 12 2Z\"/>\n        <path d=\"M20 20H4V18H20V20Z\"/>\n      </svg>\n    `;\n    downloadButton.style.cssText = `\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 8px 12px;\n      background: color-mix(in srgb, var(--xsaved-accent-color) 20%, transparent);\n      border: 1px solid color-mix(in srgb, var(--xsaved-accent-color) 40%, transparent);\n      border-radius: 20px;\n      color: var(--xsaved-accent-color);\n      cursor: pointer;\n      transition: all 0.2s ease;\n    `;\n\n    downloadButton.addEventListener('mouseenter', () => {\n      downloadButton.style.background = 'color-mix(in srgb, var(--xsaved-accent-color) 30%, transparent)';\n    });\n    downloadButton.addEventListener('mouseleave', () => {\n      downloadButton.style.background = 'color-mix(in srgb, var(--xsaved-accent-color) 20%, transparent)';\n    });\n\n    downloadButton.addEventListener('click', () => {\n      console.log('📤 Download button clicked');\n      this.showExportDialog(this.allBookmarks || []);\n    });\n    */\n\n    rightSide.appendChild(searchContainer);\n    rightSide.appendChild(sortButton);\n    // rightSide.appendChild(downloadButton); // Temporarily disabled\n\n    header.appendChild(tagSelector);\n    header.appendChild(rightSide);\n    headerContainer.appendChild(header);\n\n    // Add header to document body (outside the overlay container)\n    document.body.appendChild(headerContainer);\n\n    // Create content container with top margin to account for fixed header\n    const contentContainer = document.createElement('div');\n    contentContainer.style.cssText = `\n      margin-top: 100px;\n      padding: 0 8px;\n    `;\n\n    // Create grid container\n    const grid = document.createElement('div');\n    grid.className = 'grid';\n    grid.id = 'xsaved-bookmarks-grid';\n    \n    // Card size constraints\n    const CARD_SIZES = {\n      MIN_WIDTH: 160,    // Minimum card width\n      MAX_WIDTH: 280,    // Maximum card width  \n      IDEAL_WIDTH: 220,  // Preferred card width\n    };\n\n    // Function to calculate optimal grid layout\n    const updateOptimalGridLayout = () => {\n      // Get actual available width accounting for all padding/margins\n      const contentPadding = 16; // 8px on each side from contentContainer\n      const viewportWidth = window.innerWidth;\n      const availableWidth = viewportWidth - contentPadding;\n      \n      let columns, gap;\n      \n      console.log(`🔍 Debug: viewport=${viewportWidth}px, available=${availableWidth}px`);\n      \n      // Mobile constraint: ≤640px always shows exactly 2 columns\n      if (viewportWidth <= 640) {\n        columns = 2;\n        gap = 2;\n        console.log(`📱 Mobile mode: ${columns} columns, ${gap}px gap`);\n      } else {\n        // Calculate optimal columns for larger screens\n        // Start with ideal width and adjust based on constraints\n        let testColumns = Math.floor(availableWidth / CARD_SIZES.IDEAL_WIDTH);\n        \n        // Ensure minimum 2 columns\n        testColumns = Math.max(2, testColumns);\n        \n        // Initialize gap for calculations (will be set properly later)\n        gap = 4; // Default gap for calculations\n        \n        // Calculate actual card width with this column count\n        let actualCardWidth = (availableWidth - (gap * (testColumns - 1))) / testColumns;\n        \n        // If cards would be too wide, increase columns\n        while (actualCardWidth > CARD_SIZES.MAX_WIDTH && testColumns < 8) {\n          testColumns++;\n          actualCardWidth = (availableWidth - (gap * (testColumns - 1))) / testColumns;\n        }\n        \n        // If cards would be too narrow, decrease columns\n        while (actualCardWidth < CARD_SIZES.MIN_WIDTH && testColumns > 2) {\n          testColumns--;\n          actualCardWidth = (availableWidth - (gap * (testColumns - 1))) / testColumns;\n        }\n        \n        columns = testColumns;\n        \n        // Progressive gap sizing based on screen width\n        if (availableWidth <= 768) {\n          gap = 3;\n        } else if (availableWidth <= 1200) {\n          gap = 4;\n        } else if (availableWidth <= 1600) {\n          gap = 5;\n        } else {\n          gap = 6;\n        }\n      }\n      \n      // Apply the calculated layout with !important to override any conflicting CSS\n      grid.style.cssText = `\n        display: grid !important;\n        grid-template-columns: repeat(${columns}, 1fr) !important;\n        gap: ${gap}px !important;\n        width: 100% !important;\n        margin-bottom: 40px !important;\n        padding: 0 !important;\n        box-sizing: border-box !important;\n        justify-content: stretch !important;\n      `;\n      \n      console.log(`📐 Applied Grid: ${columns} cols, ${gap}px gap, template-columns: repeat(${columns}, 1fr)`);\n    };\n    \n    // Initial layout\n    updateOptimalGridLayout();\n    \n    // Debounced resize handler for better performance\n    let resizeTimeout;\n    const debouncedResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(updateOptimalGridLayout, 100);\n    };\n    \n    // Update on resize\n    window.addEventListener('resize', debouncedResize);\n\n    container.appendChild(contentContainer);\n    contentContainer.appendChild(grid);\n\n    // Unified search state management\n    let activeFilters = []; // All search criteria: text, author, tags, etc.\n    let searchTimeout;\n    let authorSearchTimeout;\n    let selectedAuthorIndex = -1;\n    let currentAuthors = [];\n    \n    // Unified filter management\n    const updateFilter = (type, value, label, avatarUrl) => {\n      console.log(`🔧 updateFilter called:`, { type, value, label, avatarUrl });\n      \n      // Remove existing filter of same type\n      activeFilters = activeFilters.filter(f => f.type !== type);\n      \n      // Add new filter if value provided\n      if (value && value.trim()) {\n        activeFilters.push({ type, value: value.trim(), label, avatarUrl });\n      }\n      \n      console.log(`🔧 Updated activeFilters:`, activeFilters);\n      \n      updateSearchBoxForFilters();\n      executeSearch();\n    };\n    \n    const removeFilter = (type) => {\n      activeFilters = activeFilters.filter(f => f.type !== type);\n      updateSearchBoxForFilters();\n      executeSearch();\n    };\n    \n    const clearAllFilters = () => {\n      activeFilters = [];\n      searchBox.value = '';\n      updateSearchBoxForFilters();\n      executeSearch();\n    };\n    \n    const getFilterByType = (type) => {\n      return activeFilters.find(f => f.type === type);\n    };\n    \n    const updateSearchBoxForFilters = () => {\n      // Check for author filter first (priority display)\n      const authorFilter = getFilterByType('author');\n      const textFilter = getFilterByType('text');\n      \n      if (authorFilter) {\n        // Show author filter with avatar\n        const existingAvatar = searchContainer.querySelector('.filter-avatar');\n        if (existingAvatar) {\n          existingAvatar.remove();\n        }\n        \n        // Add avatar if available\n        if (authorFilter.avatarUrl) {\n          const avatar = document.createElement('img');\n          avatar.src = authorFilter.avatarUrl;\n          avatar.className = 'filter-avatar';\n          avatar.style.cssText = `\n            position: absolute;\n            left: 12px;\n            top: 50%;\n            transform: translateY(-50%);\n            width: 20px;\n            height: 20px;\n            border-radius: 50%;\n            z-index: 1;\n          `;\n          \n          avatar.onerror = () => {\n            avatar.style.display = 'none';\n          };\n          \n          searchContainer.appendChild(avatar);\n          searchBox.style.paddingLeft = '36px';\n        } else {\n          searchBox.style.paddingLeft = '8px';\n        }\n        \n        searchBox.value = authorFilter.label + ' (click to remove)';\n        searchBox.readOnly = true;\n        searchBox.style.color = '#60A5FA';\n        searchBox.style.cursor = 'pointer';\n        \n        searchBox.onclick = () => {\n          removeFilter('author');\n        };\n      } else if (textFilter) {\n        // Show text in search box normally\n        const existingAvatar = searchContainer.querySelector('.filter-avatar');\n        if (existingAvatar) {\n          existingAvatar.remove();\n        }\n        \n        searchBox.value = textFilter.value;\n        searchBox.readOnly = false;\n        searchBox.style.color = 'white';\n        searchBox.style.cursor = 'text';\n        searchBox.style.paddingLeft = '8px';\n        searchBox.placeholder = 'Search bookmarks... (use @ for authors)';\n        searchBox.onclick = null;\n      } else {\n        // No filters - restore default\n        const existingAvatar = searchContainer.querySelector('.filter-avatar');\n        if (existingAvatar) {\n          existingAvatar.remove();\n        }\n        \n        searchBox.value = '';\n        searchBox.readOnly = false;\n        searchBox.style.color = 'white';\n        searchBox.style.cursor = 'text';\n        searchBox.style.paddingLeft = '8px';\n        searchBox.placeholder = 'Search bookmarks... (use @ for authors)';\n        searchBox.onclick = null;\n      }\n    };\n    \n    const executeSearch = () => {\n      // Build unified search query from all active filters\n      const searchQuery = {\n        limit: PAGINATION_CONFIG.INITIAL_LOAD,\n        offset: 0,\n        sortBy: this.currentSort?.field || 'created_at',\n        sortOrder: this.currentSort?.order || 'desc'\n      };\n      \n      // Apply all active filters\n      activeFilters.forEach(filter => {\n        switch (filter.type) {\n          case 'text':\n            searchQuery.text = filter.value;\n            break;\n          case 'author':\n            searchQuery.author = filter.value;\n            break;\n          case 'tag':\n            searchQuery.tags = searchQuery.tags || [];\n            searchQuery.tags.push(filter.value);\n            break;\n          // Future: date ranges, media filters, etc.\n        }\n      });\n      \n      console.log(`🔍 Unified search query:`, searchQuery, 'from filters:', activeFilters);\n      console.log(`🔍 About to call loadBookmarksPage with query:`, JSON.stringify(searchQuery, null, 2));\n      \n      // Reset pagination and execute\n      this.resetPagination();\n      this.pagination.currentQuery = searchQuery;\n      this.scrollToTopOfGrid();\n      this.loadBookmarksPage(container, searchQuery, false);\n    };\n    \n    const showAuthorDropdown = async (query = '') => {\n      try {\n        const response = await chrome.runtime.sendMessage({\n          action: 'searchAuthors',\n          query: query,\n          limit: 10\n        });\n        \n        if (response && response.success) {\n          currentAuthors = response.authors;\n          renderAuthorDropdown(currentAuthors);\n          authorDropdown.style.display = 'block';\n          selectedAuthorIndex = -1;\n        } else {\n          console.error('❌ Author search failed:', response?.error);\n        }\n      } catch (error) {\n        console.error('❌ Author search error:', error);\n      }\n    };\n    \n    const hideAuthorDropdown = () => {\n      authorDropdown.style.display = 'none';\n      selectedAuthorIndex = -1;\n      currentAuthors = [];\n    };\n    \n    const renderAuthorDropdown = (authors) => {\n      authorDropdown.innerHTML = '';\n      \n      if (authors.length === 0) {\n        const noResults = document.createElement('div');\n        noResults.textContent = 'No authors found';\n        noResults.style.cssText = `\n          padding: 12px 16px;\n          color: var(--xsaved-text-secondary);\n          font-style: italic;\n        `;\n        authorDropdown.appendChild(noResults);\n        return;\n      }\n      \n      authors.forEach((authorData, index) => {\n        const item = document.createElement('div');\n        item.className = 'author-dropdown-item';\n        item.style.cssText = `\n          padding: 12px 16px;\n          cursor: pointer;\n          border-bottom: 1px solid var(--xsaved-border-color);\n          transition: background-color 0.15s ease;\n          display: flex;\n          align-items: center;\n          gap: 12px;\n        `;\n        \n        // Create avatar image\n        const avatar = document.createElement('img');\n        avatar.src = authorData.avatar_url || '';\n        avatar.style.cssText = `\n          width: 24px;\n          height: 24px;\n          border-radius: 50%;\n          flex-shrink: 0;\n          background: var(--xsaved-border-color);\n        `;\n        \n        // Handle missing or broken avatars\n        avatar.onerror = () => {\n          avatar.style.display = 'none';\n        };\n        \n        // Create content container\n        const content = document.createElement('div');\n        content.style.cssText = `\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          flex: 1;\n        `;\n        \n        content.innerHTML = `\n          <span style=\"color: var(--xsaved-text-color); font-weight: 500;\">@${authorData.author}</span>\n          <span style=\"color: var(--xsaved-text-secondary); font-size: 12px;\">${authorData.count} tweets</span>\n        `;\n        \n        item.appendChild(avatar);\n        item.appendChild(content);\n        \n        item.addEventListener('mouseenter', () => {\n          item.style.backgroundColor = 'var(--xsaved-hover-color)';\n          selectedAuthorIndex = index;\n          updateDropdownSelection();\n        });\n        \n        item.addEventListener('mouseleave', () => {\n          item.style.backgroundColor = 'transparent';\n        });\n        \n        item.addEventListener('click', () => {\n          selectAuthor(authorData.author, authorData.avatar_url);\n        });\n        \n        authorDropdown.appendChild(item);\n      });\n    };\n    \n    const updateDropdownSelection = () => {\n      const items = authorDropdown.querySelectorAll('.author-dropdown-item');\n      items.forEach((item, index) => {\n        if (index === selectedAuthorIndex) {\n          item.style.backgroundColor = 'color-mix(in srgb, var(--xsaved-primary-color) 20%, transparent)';\n        } else {\n          item.style.backgroundColor = 'transparent';\n        }\n      });\n    };\n    \n    const selectAuthor = (author, avatarUrl) => {\n      console.log(`👤 selectAuthor called:`, { author, avatarUrl });\n      \n      // Clear the @ from search input if it exists\n      const currentValue = searchBox.value;\n      const atIndex = currentValue.lastIndexOf('@');\n      \n      // Remove text filter first (without triggering search)\n      if (atIndex !== -1) {\n        const remainingText = currentValue.substring(0, atIndex).trim();\n        activeFilters = activeFilters.filter(f => f.type !== 'text');\n        if (remainingText) {\n          activeFilters.push({ type: 'text', value: remainingText, label: remainingText });\n        }\n      }\n      \n      // Add author filter (this will trigger search once)\n      updateFilter('author', author, `@${author}`, avatarUrl);\n      \n      hideAuthorDropdown();\n      searchBox.focus();\n    };\n    \n    searchBox.addEventListener('input', (e) => {\n      // Don't process input if in filter mode (readonly)\n      if (searchBox.readOnly) {\n        return;\n      }\n      \n      const query = e.target.value;\n      console.log(`🔍 Search input event fired: \"${query}\"`);\n      \n      // Check if user typed @ symbol\n      const atIndex = query.lastIndexOf('@');\n      if (atIndex !== -1) {\n        // Extract text after the last @\n        const afterAt = query.substring(atIndex + 1);\n        console.log(`👥 @ detected, searching authors with: \"${afterAt}\"`);\n        \n        // Clear previous timeout\n        if (authorSearchTimeout) {\n          clearTimeout(authorSearchTimeout);\n        }\n        \n        // Debounce author search\n        authorSearchTimeout = setTimeout(() => {\n          showAuthorDropdown(afterAt);\n        }, 200);\n        \n        return; // Don't trigger regular search while showing author dropdown\n      } else {\n        hideAuthorDropdown();\n      }\n      \n      // Clear previous timeout\n      if (searchTimeout) {\n        clearTimeout(searchTimeout);\n      }\n      \n      // Debounce search to avoid excessive calls\n      searchTimeout = setTimeout(() => {\n        console.log(`🔍 Debounced search triggered for: \"${query}\"`);\n        // Update text filter and execute search\n        updateFilter('text', query, query);\n      }, 300); // 300ms delay\n    });\n    \n    searchBox.addEventListener('keydown', (e) => {\n      if (authorDropdown.style.display === 'block') {\n        switch (e.key) {\n          case 'ArrowDown':\n            e.preventDefault();\n            selectedAuthorIndex = Math.min(selectedAuthorIndex + 1, currentAuthors.length - 1);\n            updateDropdownSelection();\n            break;\n          case 'ArrowUp':\n            e.preventDefault();\n            selectedAuthorIndex = Math.max(selectedAuthorIndex - 1, 0);\n            updateDropdownSelection();\n            break;\n          case 'Enter':\n            e.preventDefault();\n            if (selectedAuthorIndex >= 0 && selectedAuthorIndex < currentAuthors.length) {\n              const selectedAuthor = currentAuthors[selectedAuthorIndex];\n              selectAuthor(selectedAuthor.author, selectedAuthor.avatar_url);\n            }\n            break;\n          case 'Escape':\n            e.preventDefault();\n            hideAuthorDropdown();\n            break;\n        }\n      }\n    });\n    \n    // Click outside to close dropdown\n    document.addEventListener('click', (e) => {\n      if (!searchContainer.contains(e.target)) {\n        hideAuthorDropdown();\n      }\n    });\n\n    console.log('✅ Layout rendered');\n  }\n\n  /**\n   * Render the dynamic grid content (bookmark cards)\n   * This updates only the grid items without touching the layout\n   */\n  renderGrid(bookmarks) {\n    const gridEl = document.getElementById('xsaved-bookmarks-grid');\n    if (!gridEl) {\n      console.error('❌ Grid element not found');\n      return;\n    }\n\n    gridEl.innerHTML = '';\n\n    // Group bookmarks by date\n    const groups = this.groupBookmarksByDateSimple(bookmarks);\n    groups.forEach((group, index) => {\n      // Always add date separator for each group\n      const sep = this.createDateSeparatorSimple(group.date);\n      gridEl.appendChild(sep);\n\n      // Append cards\n      group.bookmarks.forEach(b => {\n        const card = this.createBookmarkCard(b);\n        gridEl.appendChild(card);\n      });\n    });\n\n    console.log(`✅ Grid rendered with ${bookmarks.length} bookmarks`);\n  }\n\n  /**\n   * Refresh grid after background sync completes\n   * Only refreshes if we're currently showing the default view (no active filters)\n   */\n  refreshGridAfterSync() {\n    const gridOverlay = document.getElementById('xsaved-grid-overlay');\n    if (!gridOverlay) {\n      console.log('⚠️ Grid overlay not found, skipping refresh');\n      return;\n    }\n\n    // Only refresh if we're showing the default view (no active search/filters)\n    const hasActiveFilters = this.activeFilters && this.activeFilters.length > 0;\n    const hasActiveSearch = document.getElementById('xsaved-search-input')?.value?.trim();\n    \n    if (hasActiveFilters || hasActiveSearch) {\n      console.log('⏸️ Skipping grid refresh - user has active filters/search');\n      return;\n    }\n\n    console.log('🔄 Refreshing grid with latest data after sync');\n    \n    // Reset pagination and reload with fresh data\n    this.resetPagination();\n    \n    // Create fresh query for newest bookmarks\n    const query = { \n      text: '', \n      limit: PAGINATION_CONFIG.INITIAL_LOAD, \n      offset: 0,\n      sortBy: 'created_at',\n      sortOrder: 'desc' \n    };\n    \n    this.pagination.currentQuery = query;\n    this.loadBookmarksPage(gridOverlay, query, false); // false = replace existing data\n  }\n\n  hideGridInterface() {\n    console.log('🔍 Hiding XSaved grid interface...');\n    const gridOverlay = document.getElementById('xsaved-grid-overlay');\n    if (gridOverlay) {\n      gridOverlay.remove();\n    }\n\n    // Remove the fixed header\n    const fixedHeader = document.getElementById('xsaved-fixed-header');\n    if (fixedHeader) {\n      fixedHeader.remove();\n    }\n\n    // Restore scrolling on the main page\n    document.body.style.overflow = '';\n    document.documentElement.style.overflow = '';\n\n    // Reset grid state\n    isGridModeActive = false;\n\n    // Show X.com search input\n    const searchContainer = document.querySelector('div[data-xsaved-hidden=\"true\"]');\n    if (searchContainer) {\n      searchContainer.style.display = '';\n      searchContainer.removeAttribute('data-xsaved-hidden');\n    }\n  }\n\n  /**\n   * Get bookmark limit from configuration\n   * @returns {number} Bookmark limit\n   */\n  getBookmarkLimit() {\n    return DEFAULT_BOOKMARK_LIMIT;\n  }\n\n  /**\n   * Load initial bookmarks with pagination (OPTIMIZED)\n   * Loads only 50 bookmarks initially for fast rendering\n   */\n  async loadBookmarksGrid(container) {\n    console.log('📚 Loading bookmarks with pagination...');\n    \n    // Reset pagination state for fresh load\n    this.resetPagination();\n    \n    // Create initial query (use created_at for newest tweets)\n    const query = { \n      text: '', \n      limit: PAGINATION_CONFIG.INITIAL_LOAD, \n      offset: 0,\n      sortBy: 'created_at',  // FIXED: Use created_at for newest tweets\n      sortOrder: 'desc' \n    };\n    \n    // Store query for pagination\n    this.pagination.currentQuery = query;\n    \n    // Load first page\n    this.loadBookmarksPage(container, query, false); // false = not appending\n  }\n\n  /**\n   * Reset pagination state for new search/filter\n   */\n  resetPagination() {\n    this.pagination = {\n      currentOffset: 0,\n      hasMore: true,\n      isLoading: false,\n      currentQuery: null,\n      totalLoaded: 0\n    };\n    this.allBookmarks = [];\n  }\n\n  /**\n   * Load a page of bookmarks (initial or additional)\n   * @param {Element} container - Grid container\n   * @param {Object} query - Search query\n   * @param {boolean} append - Whether to append to existing results\n   */\n  loadBookmarksPage(container, query, append = true) {\n    if (this.pagination.isLoading) {\n      console.log('⏳ Already loading, skipping...');\n      return;\n    }\n    \n    this.pagination.isLoading = true;\n    \n    // Show loading indicator\n    if (append) {\n      this.showLoadingIndicator(container);\n    }\n    \n    console.log(`🔍 loadBookmarksPage: Sending search request:`, query);\n    \n    safeRuntimeMessage({ \n      action: 'searchBookmarks', \n      query: query\n    }, (response) => {\n      console.log(`🔍 loadBookmarksPage: Received response:`, response);\n      this.pagination.isLoading = false;\n      \n      if (response?.success) {\n        let bookmarks = [];\n        \n        // Handle different response structures\n        if (response.result?.bookmarks) {\n          // Search engine result: { bookmarks: ScoredBookmark[] }\n          bookmarks = response.result.bookmarks.map(scoredBookmark => {\n            return scoredBookmark.bookmark || scoredBookmark;\n          });\n        } else if (response.result?.results) {\n          // Fallback result: { results: BookmarkEntity[] }\n          bookmarks = response.result.results;\n        } else {\n          console.warn('❌ Unexpected response structure:', response);\n          this.renderGridError(container, 'Unexpected data format');\n          return;\n        }\n        \n        // REMOVED: Client-side sorting - trust database sorting!\n        \n        // Update pagination state\n        this.pagination.currentOffset += bookmarks.length;\n        this.pagination.totalLoaded += bookmarks.length;\n        this.pagination.hasMore = bookmarks.length === query.limit; // If we got less than requested, no more pages\n        \n        // Clean: No debug logging\n        \n        if (append) {\n          // Grid-only update: append and re-render items (keep header intact)\n          this.allBookmarks = [...this.allBookmarks, ...bookmarks];\n          this.renderGrid(this.allBookmarks);\n        } else {\n          // Replace dataset and render\n          this.allBookmarks = bookmarks;\n          this.renderGrid(bookmarks);\n          \n          // Initialize currentSort if not set\n          if (!this.currentSort) {\n            this.currentSort = { field: 'created_at', order: 'desc' };\n          }\n        }\n        \n        // Set up infinite scroll after first load\n        if (!append) {\n          this.setupInfiniteScroll(container);\n        }\n        \n      } else {\n        console.error('❌ Failed to load bookmarks:', response?.error);\n        this.renderGridError(container, response?.error || 'Failed to load bookmarks');\n      }\n      \n      // Hide loading indicator\n      this.hideLoadingIndicator(container);\n    });\n  }\n\n  // REMOVED: Simple append method - using re-render approach for consistent date grouping\n\n  /**\n   * Set up infinite scroll detection\n   */\n  setupInfiniteScroll(container) {\n    // Remove existing scroll listener to prevent duplicates\n    if (this.scrollListener) {\n      container.removeEventListener('scroll', this.scrollListener);\n    }\n    \n    // Create scroll listener\n    this.scrollListener = () => {\n      if (this.pagination.isLoading || !this.pagination.hasMore) {\n        return;\n      }\n      \n      const scrollTop = container.scrollTop;\n      const scrollHeight = container.scrollHeight;\n      const clientHeight = container.clientHeight;\n      \n      // Calculate scroll percentage\n      const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;\n      \n      // Trigger load when reaching threshold (90% scrolled)\n      if (scrollPercentage >= PAGINATION_CONFIG.SCROLL_THRESHOLD) {\n        this.loadMoreBookmarks(container);\n      }\n    };\n    \n    // Add scroll listener\n    container.addEventListener('scroll', this.scrollListener);\n    // Clean: No debug logging\n  }\n\n  /**\n   * Load more bookmarks (next page)\n   */\n  loadMoreBookmarks(container) {\n    if (!this.pagination.currentQuery || !this.pagination.hasMore) {\n      return;\n    }\n    \n    // Create next page query\n    const nextQuery = {\n      ...this.pagination.currentQuery,\n      offset: this.pagination.currentOffset,\n      limit: PAGINATION_CONFIG.PAGE_SIZE\n    };\n    \n    // Clean: No debug logging\n    \n    // Load next page\n    this.loadBookmarksPage(container, nextQuery, true); // true = append\n  }\n\n  /**\n   * Show loading indicator at bottom of grid\n   */\n  showLoadingIndicator(container) {\n    // Remove existing indicator\n    this.hideLoadingIndicator(container);\n    \n    const loadingDiv = document.createElement('div');\n    loadingDiv.id = 'xsaved-loading-indicator';\n    loadingDiv.style.cssText = `\n      text-align: center;\n      padding: 20px;\n      color: #666;\n      font-size: 14px;\n    `;\n    loadingDiv.innerHTML = '⏳ Loading more bookmarks...';\n    \n    container.appendChild(loadingDiv);\n  }\n\n  /**\n   * Hide loading indicator\n   */\n  hideLoadingIndicator(container) {\n    const indicator = container.querySelector('#xsaved-loading-indicator');\n    if (indicator) {\n      indicator.remove();\n    }\n  }\n\n\n\n  /**\n   * Group bookmarks by month/year using created_at and current sort\n   */\n  groupBookmarksByDateSimple(bookmarks) {\n    // Ensure sort defaults\n    if (!this.currentSort) {\n      this.currentSort = { field: 'created_at', order: 'desc' };\n    }\n\n    const grouped = bookmarks.reduce((acc, bookmark) => {\n      const date = new Date(bookmark.created_at);\n      const key = `${date.getFullYear()}-${date.getMonth()}`;\n      if (!acc[key]) {\n        acc[key] = {\n          date: new Date(date.getFullYear(), date.getMonth(), 1),\n          bookmarks: []\n        };\n      }\n      acc[key].bookmarks.push(bookmark);\n      return acc;\n    }, {});\n\n    const dir = this.currentSort.order === 'asc' ? 1 : -1;\n    return Object.values(grouped).sort((a, b) => dir * (a.date.getTime() - b.date.getTime()));\n  }\n\n  /**\n   * Create a simple date separator element\n   */\n  createDateSeparatorSimple(date) {\n    const separator = document.createElement('div');\n    separator.style.cssText = `\n      grid-column: 1 / -1;\n      display: flex;\n      align-items: center;\n      margin: 24px 0;\n      padding-left: 16px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n\n    const dateText = document.createElement('span');\n    dateText.style.cssText = `\n      font-size: 14px;\n      font-weight: 500;\n      color: #9CA3AF;\n      white-space: nowrap;\n    `;\n    dateText.textContent = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });\n\n    const line = document.createElement('div');\n    line.style.cssText = `\n      flex-grow: 1;\n      height: 1px;\n      margin-left: 16px;\n      background: linear-gradient(to right, #4B5563, transparent);\n    `;\n\n    separator.appendChild(dateText);\n    separator.appendChild(line);\n    return separator;\n  }\n\n  /**\n   * Filter bookmarks by selected tags using search engine (CONSISTENT WITH SEARCH INPUT)\n   * @param {Array} selectedTags - Array of selected tag names\n   * @param {Element} container - Grid container to update\n   */\n  async filterBookmarksByTags(selectedTags, container) {\n    console.log(`🔍 Tag filtering with search engine:`, selectedTags);\n    \n    // Update current selected tags\n    this.currentSelectedTags = new Set(selectedTags);\n    \n    // Create search query for tag filtering\n    const searchQuery = {\n      text: '', // No text search for tag filtering\n      tags: selectedTags.includes('All') || selectedTags.length === 0 ? [] : selectedTags,\n      limit: PAGINATION_CONFIG.INITIAL_LOAD,\n      offset: 0,\n      sortBy: this.currentSort?.field || 'created_at',\n      sortOrder: this.currentSort?.order || 'desc'\n    };\n    \n    console.log(`🔍 Tag search query:`, searchQuery);\n    \n    // Reset pagination for tag filtering\n    this.resetPagination();\n    this.pagination.currentQuery = searchQuery;\n    \n    // Use the same search engine flow as search input\n    this.loadBookmarksPage(container, searchQuery, false);\n  }\n\n  /**\n   * Update only the grid content without recreating the navbar\n   * @param {Array} bookmarks - Filtered bookmarks to display\n   */\n  updateGridContent(bookmarks) {\n    console.log(`🔄 Updating grid content with ${bookmarks.length} bookmarks`);\n    \n    // Find the existing grid container\n    const grid = document.getElementById('xsaved-bookmarks-grid');\n    if (!grid) {\n      console.error('❌ Grid element not found');\n      return;\n    }\n    \n    // Helper function to group bookmarks by month/year\n    const groupBookmarksByDate = (bookmarks) => {\n      // Ensure currentSort has a default value\n      if (!this.currentSort) {\n        this.currentSort = { field: 'created_at', order: 'desc' };\n      }\n      \n      // Use the same date field that was used for sorting\n      const dateField = this.currentSort.field === 'bookmarked_at' ? 'bookmarked_at' : 'created_at';\n      \n      const grouped = bookmarks.reduce((acc, bookmark) => {\n        const date = new Date(bookmark[dateField] || bookmark.created_at);\n        const monthYear = `${date.getFullYear()}-${date.getMonth()}`;\n        \n        if (!acc[monthYear]) {\n          acc[monthYear] = {\n            date: new Date(date.getFullYear(), date.getMonth(), 1),\n            bookmarks: []\n          };\n        }\n        \n        acc[monthYear].bookmarks.push(bookmark);\n        return acc;\n      }, {});\n      \n      // Respect current sort order instead of hardcoding newest first\n      const sortDirection = this.currentSort.order === 'asc' ? 1 : -1;\n      return Object.values(grouped).sort((a, b) => \n        sortDirection * (a.date.getTime() - b.date.getTime())\n      );\n    };\n\n    // Convert grouped bookmarks to grid items with separators\n    const createGridItems = (bookmarks) => {\n      const grouped = groupBookmarksByDate(bookmarks);\n      const items = [];\n      let dealIndex = 0;\n      \n      grouped.forEach((group, groupIndex) => {\n        // Add separator for each group\n        // Only show first separator if we have explicit sorting, otherwise skip first\n        const showFirstSeparator = this.currentSort && (this.currentSort.field !== 'created_at' || this.currentSort.order !== 'desc');\n        if (groupIndex > 0 || showFirstSeparator) {\n          items.push({\n            type: 'separator',\n            date: group.date\n          });\n        }\n        \n        // Add all bookmarks in this group\n        group.bookmarks.forEach(bookmark => {\n          items.push({\n            type: 'bookmark',\n            bookmark: bookmark,\n            dealIndex\n          });\n          dealIndex++;\n        });\n      });\n      \n      return items;\n    };\n\n    // Create date separator element\n    const createDateSeparator = (date) => {\n      const separator = document.createElement('div');\n      separator.style.cssText = `\n        grid-column: 1 / -1;\n        display: flex;\n        align-items: center;\n        margin: 24px 0;\n        padding-left: 16px;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      `;\n\n      const dateText = document.createElement('span');\n      dateText.style.cssText = `\n        font-size: 14px;\n        font-weight: 500;\n        color: #9CA3AF;\n        white-space: nowrap;\n      `;\n      dateText.textContent = date.toLocaleDateString('en-US', { \n        month: 'long', \n        year: 'numeric' \n      });\n\n      const line = document.createElement('div');\n      line.style.cssText = `\n        flex-grow: 1;\n        height: 1px;\n        margin-left: 16px;\n        background: linear-gradient(to right, #4B5563, transparent);\n      `;\n\n      separator.appendChild(dateText);\n      separator.appendChild(line);\n      return separator;\n    };\n\n    // Clear and re-populate grid\n    grid.innerHTML = '';\n    \n    const gridItems = createGridItems(bookmarks);\n    gridItems.forEach(item => {\n      if (item.type === 'separator') {\n        const separator = createDateSeparator(item.date);\n        grid.appendChild(separator);\n      } else {\n        const card = this.createBookmarkCard(item.bookmark);\n        grid.appendChild(card);\n      }\n    });\n    \n    console.log(`✅ Grid content updated with ${bookmarks.length} bookmarks`);\n  }\n\n\n  /**\n   * Show sort menu dropdown with filter support\n   * @param {Element} sortButton - The sort button element\n   * @param {Function} executeSearch - The executeSearch function from filter scope\n   */\n  showSortMenuWithFilters(sortButton, executeSearch) {\n    // Remove existing sort menu if any\n    const existingMenu = document.getElementById('xsaved-sort-menu');\n    if (existingMenu) {\n      existingMenu.remove();\n      return; // Toggle behavior - close if already open\n    }\n\n    // Track current sort state\n    this.currentSort = this.currentSort || { field: 'created_at', order: 'desc' };\n\n    // Create sort menu\n    const sortMenu = document.createElement('div');\n    sortMenu.id = 'xsaved-sort-menu';\n    sortMenu.style.cssText = `\n      position: absolute;\n      top: 100%;\n      right: 0;\n      background: var(--xsaved-surface-color);\n      border: 1px solid var(--xsaved-border-color);\n      border-radius: var(--xsaved-radius-medium);\n      box-shadow: var(--xsaved-shadow-heavy);\n      z-index: 10002;\n      min-width: 180px;\n      margin-top: 8px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n\n    const sortFields = [\n      { field: 'created_at', label: 'Created At' },\n      // TODO: Add bookmarked at when we have it properly fixed\n      ];\n\n    sortFields.forEach((fieldInfo, index) => {\n      const menuItem = document.createElement('div');\n      const isActive = this.currentSort.field === fieldInfo.field;\n      const currentOrder = isActive ? this.currentSort.order : 'desc';\n      const arrow = currentOrder === 'desc' ? '↓' : '↑';\n      \n      menuItem.style.cssText = `\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        padding: 12px 16px;\n        color: var(--xsaved-text-color);\n        cursor: pointer;\n        transition: background-color 0.2s ease;\n        border-bottom: ${index < sortFields.length - 1 ? '1px solid var(--xsaved-border-color)' : 'none'};\n        background-color: ${isActive ? 'var(--xsaved-hover-color)' : 'transparent'};\n      `;\n\n      menuItem.innerHTML = `\n        <span style=\"font-size: 14px; font-weight: ${isActive ? '600' : '500'};\">${fieldInfo.label}</span>\n        <span style=\"font-size: 16px; font-weight: bold; margin-left: 8px;\">${arrow}</span>\n      `;\n\n      menuItem.addEventListener('mouseenter', () => {\n        if (!isActive) {\n          menuItem.style.backgroundColor = 'var(--xsaved-hover-color)';\n        }\n      });\n\n      menuItem.addEventListener('mouseleave', () => {\n        menuItem.style.backgroundColor = isActive ? 'var(--xsaved-hover-color)' : 'transparent';\n      });\n\n      menuItem.addEventListener('click', () => {\n        // If clicking the same field, toggle order; if different field, use desc\n        let newOrder;\n        if (this.currentSort.field === fieldInfo.field) {\n          newOrder = this.currentSort.order === 'desc' ? 'asc' : 'desc';\n        } else {\n          newOrder = 'desc'; // Default to desc for new field\n        }\n        \n        console.log('🔄 Sort option selected:', `${fieldInfo.field}-${newOrder}`);\n        \n        // Update current sort state\n        this.currentSort = { field: fieldInfo.field, order: newOrder };\n        \n        // Use the new executeSearch function to preserve filters\n        executeSearch();\n        \n        sortMenu.remove();\n      });\n\n      sortMenu.appendChild(menuItem);\n    });\n\n    // Position menu relative to sort button\n    sortButton.style.position = 'relative';\n    sortButton.appendChild(sortMenu);\n\n    // Close menu when clicking outside\n    setTimeout(() => {\n      const handleOutsideClick = (e) => {\n        if (!sortMenu.contains(e.target) && !sortButton.contains(e.target)) {\n          sortMenu.remove();\n          document.removeEventListener('click', handleOutsideClick);\n        }\n      };\n      document.addEventListener('click', handleOutsideClick);\n    }, 100);\n  }\n\n  /**\n   * Scroll to top of the grid container\n   */\n  scrollToTopOfGrid() {\n    const gridOverlay = document.getElementById('xsaved-grid-overlay');\n    if (gridOverlay) {\n      gridOverlay.scrollTo({ top: 0, behavior: 'instant' });\n    }\n  }\n\n\n  /**\n   * Get currently filtered bookmarks based on active tag selection\n   * @returns {Array} Filtered bookmarks array\n   */\n  getCurrentFilteredBookmarks() {\n    if (!this.currentSelectedTags || this.currentSelectedTags.has('All')) {\n      return this.allBookmarks;\n    }\n    \n    const selectedTags = Array.from(this.currentSelectedTags);\n    return this.allBookmarks.filter(bookmark => {\n      const bookmarkTags = bookmark.tags || [];\n      return selectedTags.some(selectedTag => \n        bookmarkTags.some(bookmarkTag => \n          bookmarkTag.toLowerCase().includes(selectedTag.toLowerCase())\n        )\n      );\n    });\n  }\n\n  createBookmarkCard(bookmark) {\n    // Safe property access with fallbacks\n    const safeBookmark = {\n      id: bookmark?.id || 'unknown',\n      text: bookmark?.text || 'No content available',\n      author: bookmark?.author || 'unknown',\n      avatar_url: bookmark?.avatar_url || null,\n      tags: bookmark?.tags || [],\n      media_urls: bookmark?.media_urls || [],\n      bookmarked_at: bookmark?.bookmarked_at || bookmark?.created_at || new Date().toISOString()\n    };\n\n    const card = document.createElement('div');\n    card.setAttribute('data-bookmark-id', safeBookmark.id);\n    \n    // Apply base card styles without floating animations\n    card.className = 'tweet-card';\n    card.style.cssText = `\n      width: 100%;\n      aspect-ratio: 6/7;\n      border-radius: 6px;\n      margin: 0;\n      overflow: hidden;\n      transition: transform 0.3s ease, box-shadow 0.3s ease;\n      position: relative;\n      cursor: pointer;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n\n    // Create tag overlay (only if bookmark has tags)\n    let tagOverlay = null;\n    if (safeBookmark.tags && safeBookmark.tags.length > 0) {\n      tagOverlay = document.createElement('div');\n      tagOverlay.className = 'xsaved-tag-overlay';\n      tagOverlay.style.cssText = `\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        background: linear-gradient(transparent, rgba(0, 0, 0, 0.85));\n        color: white;\n        display: none;\n        flex-direction: column;\n        justify-content: flex-end;\n        align-items: flex-start;\n        z-index: 50;\n        border-radius: 0 0 6px 6px;\n        padding: 12px;\n        box-sizing: border-box;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n        height: 60px;\n        pointer-events: none;\n      `;\n\n      const tagsContainer = document.createElement('div');\n      tagsContainer.style.cssText = `\n        display: flex;\n        flex-wrap: wrap;\n        gap: 4px;\n        max-width: 100%;\n        overflow: hidden;\n      `;\n\n      // Limit to first 3 tags to keep it discrete\n      const visibleTags = safeBookmark.tags.slice(0, 3);\n      visibleTags.forEach(tag => {\n        const tagElement = document.createElement('span');\n        tagElement.style.cssText = `\n          background: rgba(29, 161, 242, 0.9);\n          color: white;\n          padding: 2px 6px;\n          border-radius: 8px;\n          font-size: 10px;\n          font-weight: 500;\n          white-space: nowrap;\n        `;\n        tagElement.textContent = `#${tag}`;\n        tagsContainer.appendChild(tagElement);\n      });\n\n      // Show \"+X more\" if there are more than 3 tags\n      if (safeBookmark.tags.length > 3) {\n        const moreElement = document.createElement('span');\n        moreElement.style.cssText = `\n          background: rgba(255, 255, 255, 0.2);\n          color: white;\n          padding: 2px 6px;\n          border-radius: 8px;\n          font-size: 10px;\n          font-weight: 500;\n          white-space: nowrap;\n        `;\n        moreElement.textContent = `+${safeBookmark.tags.length - 3}`;\n        tagsContainer.appendChild(moreElement);\n      }\n\n      tagOverlay.appendChild(tagsContainer);\n      card.appendChild(tagOverlay);\n    }\n\n    // Hover effect\n    card.addEventListener('mouseenter', () => {\n      card.style.transform = 'translateY(-5px)';\n      card.style.zIndex = '10000';\n      card.style.boxShadow = '0 8px 15px rgba(0, 0, 0, 0.3)';\n      if (tagOverlay) {\n        tagOverlay.style.display = 'flex';\n      }\n      xIcon.style.display = 'flex';\n    });\n\n    card.addEventListener('mouseleave', () => {\n      card.style.transform = 'translateY(0)';\n      card.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.8)';\n      if (tagOverlay) {\n        tagOverlay.style.display = 'none';\n      }\n      xIcon.style.display = 'none';\n    });\n\n    // X icon - show on hover\n    const xIcon = document.createElement('div');\n    xIcon.style.cssText = `\n      position: absolute;\n      top: 10px;\n      right: 10px;\n      width: 24px;\n      height: 24px;\n      border-radius: 50%;\n      background-color: rgba(0, 0, 0, 0.7);\n      display: none;\n      align-items: center;\n      justify-content: center;\n      cursor: pointer;\n      z-index: 200;\n      transition: background-color 0.2s ease;\n    `;\n    \n    xIcon.innerHTML = `\n      <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"#FFFFFF\">\n        <path d=\"M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z\" />\n      </svg>\n    `;\n\n    // Show/hide X icon on hover\n    card.addEventListener('mouseenter', () => {\n      xIcon.style.display = 'flex';\n    });\n\n    card.addEventListener('mouseleave', () => {\n      xIcon.style.display = 'none';\n    });\n\n    // X icon hover effect\n    xIcon.addEventListener('mouseenter', () => {\n      xIcon.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';\n    });\n\n    xIcon.addEventListener('mouseleave', () => {\n      xIcon.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';\n    });\n\n    // X icon click handler\n    xIcon.addEventListener('click', (e) => {\n      e.stopPropagation();\n      window.open(`https://x.com/i/web/status/${safeBookmark.id}`, '_blank');\n    });\n\n    // Tweet content container\n    const contentContainer = document.createElement('div');\n    contentContainer.style.cssText = `\n      position: relative;\n      z-index: 1;\n      width: 100%;\n      height: 100%;\n      padding: 16px;\n      box-sizing: border-box;\n      border-radius: 12px;\n    `;\n\n    // Profile section\n    const profileSection = document.createElement('div');\n    profileSection.style.cssText = `\n      display: flex;\n      align-items: center;\n      margin-bottom: 16px;\n    `;\n\n    // Profile pic\n    const profilePic = document.createElement('div');\n    profilePic.style.cssText = `\n      width: 32px;\n      height: 32px;\n      border-radius: 50%;\n      background-color: #5DADEC;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      color: #FFFFFF;\n      font-weight: bold;\n      margin-right: 8px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      overflow: hidden;\n    `;\n    \n    // Try to display avatar image, fallback to initials\n    if (safeBookmark.avatar_url) {\n      const avatarImg = document.createElement('img');\n      avatarImg.src = safeBookmark.avatar_url;\n      avatarImg.style.cssText = `\n        width: 100%;\n        height: 100%;\n        object-fit: cover;\n        border-radius: 50%;\n      `;\n      avatarImg.alt = safeBookmark.author;\n      \n      // Fallback to initials if image fails to load\n      avatarImg.onerror = () => {\n        profilePic.removeChild(avatarImg);\n        profilePic.textContent = safeBookmark.author.charAt(0).toUpperCase();\n      };\n      \n      profilePic.appendChild(avatarImg);\n    } else {\n      // Fallback to initial if no avatar URL\n      profilePic.textContent = safeBookmark.author.charAt(0).toUpperCase();\n    }\n\n    // User info\n    const userInfo = document.createElement('div');\n    \n    const userName = document.createElement('div');\n    userName.className = 'tweet-card-username';\n    userName.style.cssText = `\n      font-size: 14px;\n      font-weight: bold;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      max-width: 184px;\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    `;\n    userName.textContent = safeBookmark.author;\n\n    const userHandle = document.createElement('div');\n    userHandle.className = 'tweet-card-handle';\n    userHandle.style.cssText = `\n      font-size: 12px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n    userHandle.textContent = `@${safeBookmark.author}`;\n\n    userInfo.appendChild(userName);\n    userInfo.appendChild(userHandle);\n\n    profileSection.appendChild(profilePic);\n    profileSection.appendChild(userInfo);\n\n    // Tweet text\n    const tweetText = document.createElement('div');\n    tweetText.className = 'tweet-card-text';\n    tweetText.style.cssText = `\n      font-size: 14px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      margin-bottom: 16px;\n      line-height: 1.2;\n      max-height: ${safeBookmark.media_urls && safeBookmark.media_urls.length > 0 ? '100px' : '300px'};\n      overflow: hidden;\n      display: -webkit-box;\n      -webkit-line-clamp: ${safeBookmark.media_urls && safeBookmark.media_urls.length > 0 ? '3' : 'none'};\n      -webkit-box-orient: vertical;\n      text-overflow: ellipsis;\n      position: relative;\n    `;\n    tweetText.textContent = safeBookmark.text;\n\n    // Smart text truncation based on card size and media presence\n    const hasMedia = safeBookmark.media_urls && safeBookmark.media_urls.length > 0;\n    const maxTextLength = hasMedia ? 120 : 250; // Shorter text if media present\n    \n    // Check if text needs truncation and add \"more\" link\n    if (safeBookmark.text.length > maxTextLength) {\n      const moreLink = document.createElement('span');\n      moreLink.className = 'xsaved-more-link';\n      moreLink.style.cssText = `\n        color: var(--xsaved-primary-color);\n        cursor: pointer;\n        position: absolute;\n        right: 0;\n        bottom: 0;\n        background: linear-gradient(90deg, transparent, var(--xsaved-surface-color) 20%);\n        padding: 0 0 0 12px;\n        font-size: 13px;\n        font-weight: 600;\n        border-radius: 3px;\n        transition: color 0.2s ease;\n        z-index: 100;\n        pointer-events: auto;\n      `;\n      moreLink.innerHTML = '<small>more</small>';\n      \n      // Hover effect for better UX\n      moreLink.addEventListener('mouseenter', () => {\n        moreLink.style.color = 'var(--xsaved-accent-color)';\n      });\n      \n      moreLink.addEventListener('mouseleave', () => {\n        moreLink.style.color = 'var(--xsaved-primary-color)';\n      });\n      \n      moreLink.addEventListener('click', (e) => {\n        e.stopPropagation();\n        this.showTweetModal(safeBookmark);\n      });\n      \n      tweetText.appendChild(moreLink);\n    }\n\n    // Media (if any)\n    let mediaContainer = null;\n    if (safeBookmark.media_urls && safeBookmark.media_urls.length > 0) {\n      mediaContainer = document.createElement('div');\n      mediaContainer.style.cssText = `\n        width: calc(100% - 32px);\n        height: 90px;\n        margin-top: auto;\n        overflow: hidden;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        position: absolute;\n        bottom: 16px;\n        left: 16px;\n        right: 16px;\n        border-radius: 6px;\n        background: rgba(0, 0, 0, 0.05);\n      `;\n\n      const mediaImage = document.createElement('img');\n      mediaImage.src = safeBookmark.media_urls[0];\n      mediaImage.style.cssText = `\n        max-width: 100%;\n        max-height: 100%;\n        object-fit: cover;\n        image-rendering: pixelated;\n      `;\n      mediaImage.alt = '';\n\n      mediaContainer.appendChild(mediaImage);\n    }\n\n    // Tags\n    const tagsContainer = document.createElement('div');\n    tagsContainer.style.cssText = `\n      display: flex;\n      flex-wrap: wrap;\n      gap: 6px;\n      margin-bottom: 8px;\n      position: absolute;\n      bottom: ${safeBookmark.media_urls && safeBookmark.media_urls.length > 0 ? '120px' : '16px'};\n      left: 16px;\n      right: 16px;\n    `;\n\n    // Don't render tags in cards - tags are for filtering only\n    // Tags display is handled by the navbar, not individual cards\n\n    // Assemble content\n    contentContainer.appendChild(profileSection);\n    contentContainer.appendChild(tweetText);\n    if (mediaContainer) {\n      contentContainer.appendChild(mediaContainer);\n    }\n    contentContainer.appendChild(tagsContainer);\n\n    // Assemble card\n    card.appendChild(xIcon);\n    card.appendChild(contentContainer);\n\n    // Click to open original tweet\n    card.addEventListener('click', () => {\n      window.open(`https://x.com/i/web/status/${safeBookmark.id}`, '_blank');\n    });\n\n    return card;\n  }\n\n  showTweetModal(tweet) {\n    // Remove existing modal if any\n    const existingModal = document.getElementById('xsaved-tweet-modal');\n    if (existingModal) {\n      existingModal.remove();\n    }\n\n    // Create modal overlay\n    const modalOverlay = document.createElement('div');\n    modalOverlay.id = 'xsaved-tweet-modal';\n    modalOverlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background-color: rgba(0, 0, 0, 0.7);\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      z-index: 2147483647;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n\n    // Create modal content\n    const modalContent = document.createElement('div');\n    modalContent.style.cssText = `\n      background-color: #1A1A1A;\n      border-radius: 12px;\n      width: 500px;\n      max-width: 90%;\n      max-height: 90%;\n      overflow: auto;\n      padding: 24px;\n      position: relative;\n      color: #FFFFFF;\n    `;\n\n    // Close button\n    const closeButton = document.createElement('div');\n    closeButton.style.cssText = `\n      position: absolute;\n      top: 10px;\n      right: 10px;\n      color: #FFFFFF;\n      font-size: 24px;\n      cursor: pointer;\n      width: 30px;\n      height: 30px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      border-radius: 50%;\n      background-color: rgba(255, 255, 255, 0.1);\n      transition: background-color 0.2s ease;\n    `;\n    closeButton.textContent = '×';\n    \n    closeButton.addEventListener('mouseenter', () => {\n      closeButton.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';\n    });\n    \n    closeButton.addEventListener('mouseleave', () => {\n      closeButton.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';\n    });\n\n    // Profile section\n    const profileSection = document.createElement('div');\n    profileSection.style.cssText = `\n      display: flex;\n      align-items: center;\n      margin-bottom: 24px;\n    `;\n\n    // Profile pic\n    const profilePic = document.createElement('div');\n    profilePic.style.cssText = `\n      width: 48px;\n      height: 48px;\n      border-radius: 50%;\n      background-color: #5DADEC;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      color: #FFFFFF;\n      font-weight: bold;\n      margin-right: 12px;\n      font-size: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      overflow: hidden;\n    `;\n    \n    // Try to display avatar image, fallback to initials\n    if (tweet.avatar_url) {\n      const avatarImg = document.createElement('img');\n      avatarImg.src = tweet.avatar_url;\n      avatarImg.style.cssText = `\n        width: 100%;\n        height: 100%;\n        object-fit: cover;\n        border-radius: 50%;\n      `;\n      avatarImg.alt = tweet.author;\n      \n      // Fallback to initials if image fails to load\n      avatarImg.onerror = () => {\n        profilePic.removeChild(avatarImg);\n        profilePic.textContent = tweet.author.charAt(0).toUpperCase();\n      };\n      \n      profilePic.appendChild(avatarImg);\n    } else {\n      // Fallback to initial if no avatar URL\n      profilePic.textContent = tweet.author.charAt(0).toUpperCase();\n    }\n\n    // User info\n    const userInfo = document.createElement('div');\n    \n    const userName = document.createElement('div');\n    userName.style.cssText = `\n      color: #FFFFFF;\n      font-size: 18px;\n      font-weight: bold;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      margin-bottom: 4px;\n    `;\n    userName.textContent = tweet.author;\n\n    const userHandle = document.createElement('div');\n    userHandle.style.cssText = `\n      color: #888888;\n      font-size: 14px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n    userHandle.textContent = `@${tweet.author}`;\n\n    userInfo.appendChild(userName);\n    userInfo.appendChild(userHandle);\n\n    profileSection.appendChild(profilePic);\n    profileSection.appendChild(userInfo);\n\n    // Tweet text\n    const tweetText = document.createElement('div');\n    tweetText.style.cssText = `\n      color: #FFFFFF;\n      font-size: 16px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      margin-bottom: 24px;\n      line-height: 1.5;\n    `;\n    tweetText.textContent = tweet.text;\n\n    // Media (if any)\n    let mediaSection = null;\n    if (tweet.media_urls && tweet.media_urls.length > 0) {\n      mediaSection = document.createElement('div');\n      mediaSection.style.cssText = `\n        width: 100%;\n        max-height: 400px;\n        overflow: hidden;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        border-radius: 12px;\n        margin-bottom: 16px;\n      `;\n\n      const mediaImage = document.createElement('img');\n      mediaImage.src = tweet.media_urls[0];\n      mediaImage.style.cssText = `\n        width: 100%;\n        object-fit: contain;\n        max-height: 400px;\n      `;\n      mediaImage.alt = '';\n\n      mediaSection.appendChild(mediaImage);\n    }\n\n    // Tags\n    const tagsSection = document.createElement('div');\n    tagsSection.style.cssText = `\n      display: flex;\n      flex-wrap: wrap;\n      gap: 8px;\n      margin-bottom: 16px;\n    `;\n\n    if (tweet.tags && tweet.tags.length > 0) {\n      tweet.tags.forEach(tag => {\n        const tagElement = document.createElement('span');\n        tagElement.style.cssText = `\n          background: rgba(29, 161, 242, 0.2);\n          color: #1DA1F2;\n          padding: 6px 12px;\n          border-radius: 16px;\n          font-size: 14px;\n          font-weight: 500;\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n        `;\n        tagElement.textContent = `#${tag}`;\n        tagsSection.appendChild(tagElement);\n      });\n    } else {\n      // Show placeholder if no tags\n      const noTagsElement = document.createElement('span');\n      noTagsElement.style.cssText = `\n        color: rgba(255, 255, 255, 0.4);\n        font-size: 14px;\n        font-style: italic;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      `;\n      noTagsElement.textContent = 'No tags';\n      tagsSection.appendChild(noTagsElement);\n    }\n\n    // Timestamp\n    const timestamp = document.createElement('div');\n    timestamp.style.cssText = `\n      color: rgba(255, 255, 255, 0.6);\n      font-size: 14px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n    timestamp.textContent = new Date(tweet.bookmarked_at).toLocaleString();\n\n    // Assemble modal\n    modalContent.appendChild(closeButton);\n    modalContent.appendChild(profileSection);\n    modalContent.appendChild(tweetText);\n    if (mediaSection) {\n      modalContent.appendChild(mediaSection);\n    }\n    modalContent.appendChild(tagsSection);\n    modalContent.appendChild(timestamp);\n\n    modalOverlay.appendChild(modalContent);\n\n    // Event listeners\n    const closeModal = () => {\n      modalOverlay.remove();\n    };\n\n    closeButton.addEventListener('click', closeModal);\n    modalOverlay.addEventListener('click', (e) => {\n      if (e.target === modalOverlay) {\n        closeModal();\n      }\n    });\n\n    // Keyboard support\n    const handleKeyDown = (e) => {\n      if (e.key === 'Escape') {\n        closeModal();\n        document.removeEventListener('keydown', handleKeyDown);\n      }\n    };\n    document.addEventListener('keydown', handleKeyDown);\n\n    // Add to page\n    document.body.appendChild(modalOverlay);\n  }\n\n  renderGridError(container, message) {\n    container.innerHTML = `\n      <div style=\"\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        height: 300px;\n        color: white;\n        text-align: center;\n      \">\n        <div style=\"font-size: 48px; margin-bottom: 16px;\">❌</div>\n        <div style=\"font-size: 18px; margin-bottom: 8px;\">Oops!</div>\n        <div style=\"color: rgba(255, 255, 255, 0.7);\">${message}</div>\n      </div>\n    `;\n  }\n\n  /**\n   * @deprecated - Use executeSearch() instead. This method is kept for compatibility but should not be used.\n   */\n  filterBookmarksPage(query, container, bookmarks) {\n    console.warn('🚨 filterBookmarksPage is deprecated. Use executeSearch() instead.');\n    return; // Method disabled\n    console.log(`🔍 Search input: \"${query}\"`);\n    \n    // Create search query with current sorting\n    const searchQuery = {\n      text: query.trim(),\n      limit: PAGINATION_CONFIG.INITIAL_LOAD,\n      offset: 0,\n      sortBy: this.currentSort?.field || 'created_at',\n      sortOrder: this.currentSort?.order || 'desc'\n    };\n    \n    console.log(`🔍 Search query:`, searchQuery);\n    \n    // Reset pagination and search\n    this.resetPagination();\n    this.pagination.currentQuery = searchQuery;\n    \n    // Scroll to top of grid when searching\n    this.scrollToTopOfGrid();\n    \n    // Load search results with pagination - use append=false to replace results\n    this.loadBookmarksPage(container, searchQuery, false);\n    \n    // No setTimeout needed - search input stays intact since we don't rebuild the entire DOM\n    return;\n    \n    // OLD CODE BELOW - keeping for reference but not executed\n    const filteredBookmarks = [];\n\n    // Helper function to group bookmarks by month/year (same as in renderBookmarksGrid)\n    const groupBookmarksByDate = (bookmarks) => {\n      const grouped = bookmarks.reduce((acc, bookmark) => {\n        const date = new Date(bookmark.created_at);\n        const monthYear = `${date.getFullYear()}-${date.getMonth()}`;\n        \n        if (!acc[monthYear]) {\n          acc[monthYear] = {\n            date: new Date(date.getFullYear(), date.getMonth(), 1),\n            bookmarks: []\n          };\n        }\n        \n        acc[monthYear].bookmarks.push(bookmark);\n        return acc;\n      }, {});\n      \n      return Object.values(grouped).sort((a, b) => b.date.getTime() - a.date.getTime());\n    };\n\n    // Convert grouped bookmarks to grid items with separators\n    const createGridItems = (bookmarks) => {\n      const grouped = groupBookmarksByDate(bookmarks);\n      const items = [];\n      let dealIndex = 0;\n      \n      grouped.forEach((group, groupIndex) => {\n        // Add separator for each group\n        // Only show first separator if we have explicit sorting, otherwise skip first\n        const showFirstSeparator = this.currentSort && (this.currentSort.field !== 'created_at' || this.currentSort.order !== 'desc');\n        if (groupIndex > 0 || showFirstSeparator) {\n          items.push({\n            type: 'separator',\n            date: group.date\n          });\n        }\n        \n        // Add all bookmarks in this group\n        group.bookmarks.forEach(bookmark => {\n          items.push({\n            type: 'bookmark',\n            bookmark: bookmark,\n            dealIndex\n          });\n          dealIndex++;\n        });\n      });\n      \n      return items;\n    };\n\n    // Create date separator element (matching DateSeparator.tsx exactly)\n    const createDateSeparator = (date) => {\n      const separator = document.createElement('div');\n      separator.style.cssText = `\n        grid-column: 1 / -1;\n        display: flex;\n        align-items: center;\n        margin: 24px 0;\n        padding-left: 16px;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      `;\n\n      const dateText = document.createElement('span');\n      dateText.style.cssText = `\n        font-size: 14px;\n        font-weight: 500;\n        color: #9CA3AF;\n        white-space: nowrap;\n      `;\n      dateText.textContent = date.toLocaleDateString('en-US', { \n        month: 'long', \n        year: 'numeric' \n      });\n\n      const line = document.createElement('div');\n      line.style.cssText = `\n        flex-grow: 1;\n        height: 1px;\n        margin-left: 16px;\n        background: linear-gradient(to right, #4B5563, transparent);\n      `;\n\n      separator.appendChild(dateText);\n      separator.appendChild(line);\n      return separator;\n    };\n\n    // Clear and re-render grid with grouped structure\n    grid.innerHTML = '';\n    const gridItems = createGridItems(filteredBookmarks);\n    gridItems.forEach(item => {\n      if (item.type === 'separator') {\n        const separator = createDateSeparator(item.date);\n        grid.appendChild(separator);\n      } else {\n        const card = this.createBookmarkCard(item.bookmark);\n        grid.appendChild(card);\n      }\n    });\n    \n    // Scroll to top after search/filtering\n    this.scrollToTopOfGrid();\n  }\n\n\n  setupBookmarksPageObserver() {\n    // Observe for dynamic content changes on bookmarks page\n    // This helps maintain the toggle when X.com updates the page\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'childList') {\n          // Check if toggle still exists and we're on bookmarks page\n          const toggle = document.getElementById('xsaved-bookmarks-toggle');\n          if (!toggle && XSAVED_CONFIG.pages.isBookmarksPage()) {\n            console.log('🔄 Re-adding bookmarks toggle after page update');\n            // Use the new strict validation system\n            this.attemptBookmarksTogglePlacement();\n          }\n        }\n      });\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  }\n\n  // ===== BOOKMARK BUTTON INTERCEPTION =====\n  initializeBookmarkInterception() {\n    console.log('🔖 Initializing bookmark button interception...');\n    \n    // Initial scan for bookmark buttons\n    this.interceptBookmarkButtons();\n    \n    // Set up observer for dynamically added buttons\n    this.setupBookmarkButtonObserver();\n  }\n\n  setupBookmarkButtonObserver() {\n    if (bookmarkButtonObserver) {\n      bookmarkButtonObserver.disconnect();\n    }\n\n    bookmarkButtonObserver = new MutationObserver((mutations) => {\n      let shouldRescan = false;\n      \n      mutations.forEach((mutation) => {\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          // Check if new nodes contain bookmark buttons\n          mutation.addedNodes.forEach((node) => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              const hasBookmarkButton = node.querySelector && \n                (node.querySelector(XSAVED_CONFIG.selectors.bookmarkButton) || \n                 node.matches && node.matches(XSAVED_CONFIG.selectors.bookmarkButton));\n              \n              if (hasBookmarkButton) {\n                shouldRescan = true;\n              }\n            }\n          });\n        }\n      });\n\n      if (shouldRescan) {\n        // Debounce the rescan\n        clearTimeout(this.rescanTimeout);\n        this.rescanTimeout = setTimeout(() => {\n          this.interceptBookmarkButtons();\n        }, 300);\n      }\n    });\n\n    bookmarkButtonObserver.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  }\n\n  interceptBookmarkButtons() {\n    const bookmarkButtons = document.querySelectorAll(XSAVED_CONFIG.selectors.bookmarkButton);\n    console.log(`🔍 Found ${bookmarkButtons.length} bookmark buttons`);\n\n    bookmarkButtons.forEach((button, index) => {\n      // Debug button details\n      const ariaLabel = button.getAttribute('aria-label') || '';\n      const dataTestId = button.getAttribute('data-testid') || '';\n      console.log(`🔍 Button ${index + 1}:`, {\n        ariaLabel,\n        dataTestId,\n        isAlreadyIntercepted: interceptedButtons.has(button),\n        hasXSavedClass: button.classList.contains('xsaved-intercepted')\n      });\n\n      // Skip if already intercepted\n      if (interceptedButtons.has(button)) {\n        console.log(`⏭️ Button ${index + 1} already intercepted, skipping`);\n        return;\n      }\n\n      // Validate this is actually a bookmark button\n      if (!this.isValidBookmarkButton(button)) {\n        console.warn(`❌ Button ${index + 1} failed validation, skipping`);\n        return;\n      }\n\n      // Mark as intercepted\n      interceptedButtons.add(button);\n      button.classList.add('xsaved-intercepted');\n      \n      // Extract tweet data\n      const tweetData = this.extractTweetDataFromButton(button);\n      if (!tweetData) {\n        console.warn(`❌ Could not extract tweet data from bookmark button ${index + 1}`);\n        return;\n      }\n\n      console.log(`✅ Successfully extracted tweet data for button ${index + 1}:`, tweetData);\n\n      // Add our click handler\n      button.addEventListener('click', (e) => {\n        console.log('🖱️ Bookmark button clicked!');\n        console.log('🔍 Button that was clicked:', {\n          ariaLabel: button.getAttribute('aria-label'),\n          dataTestId: button.getAttribute('data-testid'),\n          buttonElement: button\n        });\n        \n        const isBookmarking = this.checkIfBookmarkAction(button);\n        console.log('Is bookmarking action:', isBookmarking);\n        \n        if (isBookmarking) {\n          // Store event details for tooltip positioning\n          const eventDetails = {\n            clientX: e.clientX,\n            clientY: e.clientY\n          };\n          \n          // Let native bookmark action execute first\n          console.log('Allowing native bookmark action to proceed...');\n          \n          // AUTO-SAVE: Immediately save to IndexedDB with default tags\n          console.log('💾 Auto-saving bookmark to IndexedDB...');\n          this.autoSaveBookmark(tweetData);\n          \n          // Show our save dialog after delay for optional tagging\n          setTimeout(() => {\n            console.log('🏷️ Showing save dialog for optional tagging...');\n            const syntheticEvent = {\n              clientX: eventDetails.clientX,\n              clientY: eventDetails.clientY,\n              preventDefault: () => {},\n              stopPropagation: () => {}\n            };\n            this.showSaveDialog(syntheticEvent, tweetData, button);\n          }, 200);\n        } else {\n          console.log('🔄 This is an unbookmark action, no dialog needed');\n        }\n      }, false);\n    });\n\n    console.log(`✅ Successfully intercepted ${bookmarkButtons.length} bookmark buttons`);\n  }\n\n  extractTweetDataFromButton(button) {\n    try {\n      // Navigate up the DOM to find the tweet container\n      let tweetContainer = button.closest(XSAVED_CONFIG.selectors.tweetContainer);\n      if (!tweetContainer) {\n        console.warn('Could not find tweet container');\n        return null;\n      }\n\n      // Extract tweet ID from data attributes or URLs\n      const tweetId = this.extractTweetId(tweetContainer);\n      if (!tweetId) {\n        console.warn('Could not extract tweet ID');\n        return null;\n      }\n\n      // Extract text content\n      const tweetTextElement = tweetContainer.querySelector(XSAVED_CONFIG.selectors.tweetText);\n      const text = tweetTextElement ? tweetTextElement.textContent.trim() : '';\n\n      // Extract author\n      const userNameElement = tweetContainer.querySelector(XSAVED_CONFIG.selectors.userName);\n      const author = userNameElement ? \n        userNameElement.textContent.replace('@', '').trim() : \n        'unknown';\n\n      // Extract avatar URL\n      const avatarElement = tweetContainer.querySelector(XSAVED_CONFIG.selectors.userAvatar + ' img');\n      const avatar_url = avatarElement ? avatarElement.getAttribute('src') : null;\n\n      // Extract creation timestamp (best effort)\n      const timeElement = tweetContainer.querySelector('time');\n      const created_at = timeElement ? \n        timeElement.getAttribute('datetime') || new Date().toISOString() : \n        new Date().toISOString();\n\n      // Extract media URLs\n      const media_urls = this.extractMediaUrls(tweetContainer);\n\n      return {\n        id: tweetId,\n        text,\n        author,\n        avatar_url,\n        created_at,\n        media_urls\n      };\n\n    } catch (error) {\n      console.error('Error extracting tweet data:', error);\n      return null;\n    }\n  }\n\n  extractTweetId(tweetContainer) {\n    // Try multiple methods to extract tweet ID\n    \n    // Method 1: Look for links to the tweet\n    const tweetLinks = tweetContainer.querySelectorAll('a[href*=\"/status/\"]');\n    for (const link of tweetLinks) {\n      const href = link.getAttribute('href');\n      const match = href.match(/\\/status\\/(\\d+)/);\n      if (match) {\n        return match[1];\n      }\n    }\n\n    // Method 2: Look for data attributes\n    const dataId = tweetContainer.getAttribute('data-tweet-id') || \n                   tweetContainer.getAttribute('data-testid');\n    if (dataId && /^\\d+/.test(dataId)) {\n      return dataId;\n    }\n\n    // Method 3: Check for aria-labelledby or other ID patterns\n    const ariaLabelledBy = tweetContainer.getAttribute('aria-labelledby');\n    if (ariaLabelledBy) {\n      const match = ariaLabelledBy.match(/(\\d+)/);\n      if (match) {\n        return match[1];\n      }\n    }\n\n    return null;\n  }\n\n\n\n  extractMediaUrls(tweetContainer) {\n    const media_urls = [];\n    \n    // Extract images\n    const images = tweetContainer.querySelectorAll('img[src*=\"pbs.twimg.com\"]');\n    images.forEach(img => {\n      const src = img.getAttribute('src');\n      if (src && !media_urls.includes(src)) {\n        media_urls.push(src);\n      }\n    });\n\n    // Extract videos (placeholder URLs)\n    const videos = tweetContainer.querySelectorAll('video');\n    videos.forEach(video => {\n      const poster = video.getAttribute('poster');\n      if (poster && !media_urls.includes(poster)) {\n        media_urls.push(poster);\n      }\n    });\n\n    return media_urls;\n  }\n\n  isValidBookmarkButton(button) {\n    const ariaLabel = button.getAttribute('aria-label') || '';\n    const dataTestId = button.getAttribute('data-testid') || '';\n    \n    // Must have correct data-testid\n    const hasValidTestId = dataTestId === 'bookmark' || dataTestId === 'removeBookmark';\n    \n    // Must have correct aria-label. Using third check cause in status page aria-label look like this : 102 Bookmarks. Bookmarked\n    const hasValidAriaLabel = ariaLabel === 'Bookmark' || ariaLabel === 'Bookmarked' || ariaLabel.toLowerCase().includes('bookmark');\n    \n    // Must NOT be a share button\n    const isNotShareButton = !ariaLabel.toLowerCase().includes('share');\n    \n    // Must have bookmark icon (SVG with bookmark path)\n    const svg = button.querySelector('svg');\n    const hasBookmarkIcon = svg && svg.querySelector('path[d*=\"4.5C4 3.12\"]'); // Part of bookmark icon path\n    \n    const isValid = hasValidTestId && hasValidAriaLabel && isNotShareButton && hasBookmarkIcon;\n    \n    console.log('🔍 Button validation:', {\n      ariaLabel,\n      dataTestId,\n      hasValidTestId,\n      hasValidAriaLabel,\n      isNotShareButton,\n      hasBookmarkIcon,\n      isValid\n    });\n    \n    return isValid;\n  }\n\n  checkIfBookmarkAction(button) {\n    const ariaLabel = button.getAttribute('aria-label') || '';\n    const dataTestId = button.getAttribute('data-testid') || '';\n    \n    // More precise detection based on data-testid\n    const isCurrentlyBookmarked = dataTestId === 'removeBookmark' || ariaLabel === 'Bookmarked';\n    const willBookmark = !isCurrentlyBookmarked;\n    \n    console.log('🔍 Checking bookmark action state:');\n    console.log('  aria-label:', ariaLabel);\n    console.log('  data-testid:', dataTestId);\n    console.log('  is currently bookmarked:', isCurrentlyBookmarked);\n    console.log('  → Will bookmark:', willBookmark);\n    \n    return willBookmark;\n  }\n\n  // ===== SAVE DIALOG =====\n  showSaveDialog(event, tweetData, bookmarkButton) {\n    console.log('🏷️ showSaveDialog called with:', { tweetData, event: !!event, button: !!bookmarkButton });\n    \n    // Remove existing dialog\n    this.removeTooltip();\n    \n    const dialog = this.createSaveDialog(event, tweetData);\n    currentTooltip = dialog;\n    \n    console.log('📦 Created save dialog element:', !!dialog);\n    \n    // Position dialog\n    this.positionTooltip(dialog, event);\n    \n    // Add to DOM with animation\n    document.body.appendChild(dialog);\n    \n    // Trigger fade-in animation\n    setTimeout(() => {\n      dialog.style.opacity = '1';\n      dialog.style.transform = 'translateY(0) scale(1)';\n    }, 10);\n    \n    console.log('✅ Save dialog added to DOM');\n    \n    // Focus the input after animation completes\n    const input = dialog.querySelector('.xsaved-tag-input');\n    if (input) {\n      setTimeout(() => {\n        try {\n          input.focus();\n          console.log('🎯 Input focused successfully');\n        } catch (error) {\n          console.warn('⚠️ Failed to focus input:', error);\n          // Retry focus\n          setTimeout(() => {\n            try {\n              input.focus();\n              console.log('🎯 Input focused on retry');\n            } catch (retryError) {\n              console.error('❌ Focus retry failed:', retryError);\n            }\n          }, 200);\n        }\n      }, 350); // Wait for fade-in animation to complete\n    }\n    \n    // Set auto-fade timeout\n    this.resetTooltipTimeout();\n  }\n\n  createSaveDialog(event, tweetData) {\n    const dialog = document.createElement('div');\n    dialog.className = 'xsaved-save-dialog';\n    dialog.style.cssText = `\n      position: fixed;\n      background: var(--xsaved-surface-color);\n      backdrop-filter: blur(16px);\n      border: 1px solid var(--xsaved-border-color);\n      border-radius: 16px;\n      padding: 20px;\n      z-index: 10000;\n      box-shadow: var(--xsaved-shadow-heavy);\n      min-width: 320px;\n      max-width: 400px;\n      font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n      color: var(--xsaved-text-color);\n      opacity: 0;\n      transform: translateY(15px) scale(0.95);\n      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n    `;\n\n    // Header\n    const header = document.createElement('div');\n    header.style.cssText = `\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      margin-bottom: 16px;\n      font-size: 16px;\n      font-weight: 600;\n      color: var(--xsaved-text-color);\n    `;\n\n    const headerLeft = document.createElement('div');\n    headerLeft.style.cssText = `\n      display: flex;\n      align-items: center;\n      gap: 8px;\n    `;\n    headerLeft.innerHTML = `\n      <svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <path d=\"M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z\"/>\n      </svg>\n      Bookmark Saved! Add Tags?\n    `;\n\n    const closeButton = document.createElement('button');\n    closeButton.textContent = '×';\n    closeButton.style.cssText = `\n      background: none;\n      border: none;\n      color: var(--xsaved-text-secondary);\n      font-size: 20px;\n      cursor: pointer;\n      padding: 0;\n      line-height: 1;\n    `;\n    closeButton.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log('❌ Close button clicked');\n      this.removeTooltip();\n    });\n\n    header.appendChild(headerLeft);\n    header.appendChild(closeButton);\n\n    // Tweet preview\n    const preview = document.createElement('div');\n    preview.style.cssText = `\n      background: color-mix(in srgb, var(--xsaved-border-color) 20%, transparent);\n      border-radius: 8px;\n      padding: 12px;\n      margin-bottom: 16px;\n      border-left: 3px solid var(--xsaved-primary-color);\n    `;\n\n    const previewAuthor = document.createElement('div');\n    previewAuthor.style.cssText = `\n      font-weight: 600;\n      color: var(--xsaved-primary-color);\n      font-size: 14px;\n      margin-bottom: 4px;\n    `;\n    previewAuthor.textContent = `@${tweetData.author}`;\n\n    const previewText = document.createElement('div');\n    previewText.style.cssText = `\n      color: var(--xsaved-text-color);\n      font-size: 13px;\n      line-height: 1.4;\n    `;\n    previewText.textContent = tweetData.text.length > 120 \n      ? tweetData.text.substring(0, 120) + '...' \n      : tweetData.text;\n\n    preview.appendChild(previewAuthor);\n    preview.appendChild(previewText);\n\n    // Tags input section\n    const tagsSection = document.createElement('div');\n    tagsSection.style.cssText = `margin-bottom: 16px;`;\n\n    const tagsLabel = document.createElement('label');\n    tagsLabel.style.cssText = `\n      display: block;\n      margin-bottom: 8px;\n      font-size: 14px;\n      font-weight: 500;\n      color: var(--xsaved-text-color);\n    `;\n    tagsLabel.textContent = 'Tags (optional):';\n\n    // Container for visual tags\n    const tagsContainer = document.createElement('div');\n    tagsContainer.className = 'xsaved-tags-container';\n    tagsContainer.style.cssText = `\n      display: flex;\n      flex-wrap: wrap;\n      gap: 6px;\n      margin-bottom: 8px;\n      min-height: 28px;\n      padding: 8px;\n      border: 1px solid var(--xsaved-border-color);\n      border-radius: 8px;\n      background: var(--xsaved-input-bg);\n    `;\n\n    const tagsInput = document.createElement('input');\n    tagsInput.type = 'text';\n    tagsInput.className = 'xsaved-tag-input';\n    tagsInput.placeholder = 'Type tags and press space or comma...';\n    tagsInput.style.setProperty('--placeholder-color', 'var(--xsaved-placeholder-color)');\n    tagsInput.style.cssText = `\n      width: 100%;\n      padding: 8px 12px;\n      border: 1px solid var(--xsaved-border-color);\n      border-radius: 8px;\n      background: var(--xsaved-input-bg);\n      color: var(--xsaved-text-color);\n      font-size: 14px;\n      font-family: inherit;\n      outline: none;\n      transition: border-color 0.2s ease;\n    `;\n\n    // Store tags array\n    const currentTags = [];\n\n    // Helper function to create a tag element\n    const createTagElement = (tagText) => {\n      const tagElement = document.createElement('span');\n      tagElement.style.cssText = `\n        display: inline-flex;\n        align-items: center;\n        gap: 4px;\n        background: color-mix(in srgb, var(--xsaved-primary-color) 20%, transparent);\n        color: var(--xsaved-primary-color);\n        padding: 4px 8px;\n        border-radius: 12px;\n        font-size: 12px;\n        font-weight: 500;\n        user-select: none;\n      `;\n      \n      const tagLabel = document.createElement('span');\n      tagLabel.textContent = `#${tagText}`;\n      \n      const removeButton = document.createElement('button');\n      removeButton.textContent = '×';\n      removeButton.style.cssText = `\n        background: none;\n        border: none;\n        color: currentColor;\n        cursor: pointer;\n        font-size: 14px;\n        line-height: 1;\n        padding: 0;\n        margin-left: 2px;\n      `;\n      \n      removeButton.addEventListener('click', (e) => {\n        // Prevent event from bubbling up and closing the dialog\n        e.preventDefault();\n        e.stopPropagation();\n        \n        // Clear auto-fade timeout when user is actively interacting\n        this.clearTooltipTimeout();\n        \n        const index = currentTags.indexOf(tagText);\n        if (index > -1) {\n          currentTags.splice(index, 1);\n          tagElement.remove();\n          console.log(`🏷️ Removed tag: \"${tagText}\"`);\n        }\n      });\n      \n      tagElement.appendChild(tagLabel);\n      tagElement.appendChild(removeButton);\n      return tagElement;\n    };\n\n    // Helper function to add a tag\n    const addTag = (tagText) => {\n      const cleanTag = tagText.trim().replace(/^#/, '');\n      if (cleanTag && !currentTags.includes(cleanTag)) {\n        currentTags.push(cleanTag);\n        const tagElement = createTagElement(cleanTag);\n        tagsContainer.appendChild(tagElement);\n      }\n    };\n\n    // Input event handlers for tag creation\n    tagsInput.addEventListener('input', (e) => {\n      // Clear auto-fade timeout when user is actively typing\n      this.clearTooltipTimeout();\n      \n      const value = e.target.value;\n      const lastChar = value.slice(-1);\n      \n      // Create tag on space or comma\n      if (lastChar === ' ' || lastChar === ',') {\n        const tagText = value.slice(0, -1);\n        if (tagText.trim()) {\n          addTag(tagText);\n          e.target.value = '';\n        }\n      }\n    });\n\n    tagsInput.addEventListener('keydown', (e) => {\n      // Clear auto-fade timeout when user is actively typing\n      this.clearTooltipTimeout();\n      \n      // Create tag on Enter\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        const tagText = e.target.value.trim();\n        if (tagText) {\n          addTag(tagText);\n          e.target.value = '';\n        }\n      }\n      \n      // Remove last tag on backspace when input is empty\n      if (e.key === 'Backspace' && e.target.value === '' && currentTags.length > 0) {\n        const lastTag = currentTags.pop();\n        const lastTagElement = tagsContainer.lastElementChild;\n        if (lastTagElement) {\n          lastTagElement.remove();\n        }\n      }\n    });\n\n    // Also handle paste events\n    tagsInput.addEventListener('paste', (e) => {\n      console.log('📋 User pasted text, clearing auto-fade timeout');\n      this.clearTooltipTimeout();\n    });\n\n    // Input focus effects\n    tagsInput.addEventListener('focus', () => {\n      tagsInput.style.borderColor = 'var(--xsaved-primary-color)';\n      tagsContainer.style.borderColor = 'var(--xsaved-primary-color)';\n      // Only reset timeout on initial focus, not on every interaction\n      this.resetTooltipTimeout();\n    });\n    tagsInput.addEventListener('blur', () => {\n      tagsInput.style.borderColor = 'var(--xsaved-border-color)';\n      tagsContainer.style.borderColor = 'var(--xsaved-border-color)';\n      \n      // Add any remaining text as a tag\n      const remainingText = tagsInput.value.trim();\n      if (remainingText) {\n        addTag(remainingText);\n        tagsInput.value = '';\n      }\n      \n      // Restart auto-fade timeout when user stops interacting with input\n      setTimeout(() => {\n        this.resetTooltipTimeout();\n      }, 100); // Small delay to avoid conflicts with other interactions\n    });\n\n    tagsSection.appendChild(tagsLabel);\n    tagsSection.appendChild(tagsContainer);\n    tagsSection.appendChild(tagsInput);\n\n    // Action buttons\n    const actionsContainer = document.createElement('div');\n    actionsContainer.style.cssText = `\n      display: flex;\n      gap: 12px;\n      justify-content: flex-end;\n    `;\n\n    const cancelButton = document.createElement('button');\n    cancelButton.textContent = 'Cancel';\n    cancelButton.style.cssText = `\n      padding: 8px 16px;\n      border: 1px solid var(--xsaved-border-color);\n      border-radius: 6px;\n      background: transparent;\n      color: var(--xsaved-text-secondary);\n      font-size: 14px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n    `;\n    cancelButton.addEventListener('click', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log('🚫 Cancel button clicked');\n      this.removeTooltip();\n    });\n\n    const saveButton = document.createElement('button');\n    saveButton.textContent = 'Add Tags';\n    saveButton.style.cssText = `\n      padding: 8px 20px;\n      border: none;\n      border-radius: 6px;\n      background: var(--xsaved-primary-color);\n      color: var(--xsaved-bg-color);\n      font-size: 14px;\n      font-weight: 600;\n      cursor: pointer;\n      transition: all 0.2s ease;\n    `;\n\n    // Button hover effects\n    cancelButton.addEventListener('mouseenter', () => {\n      cancelButton.style.backgroundColor = 'var(--xsaved-hover-color)';\n      cancelButton.style.color = 'var(--xsaved-text-color)';\n    });\n    cancelButton.addEventListener('mouseleave', () => {\n      cancelButton.style.backgroundColor = 'transparent';\n      cancelButton.style.color = 'var(--xsaved-text-secondary)';\n    });\n\n    saveButton.addEventListener('mouseenter', () => {\n      saveButton.style.filter = 'brightness(0.9)';\n    });\n    saveButton.addEventListener('mouseleave', () => {\n      saveButton.style.filter = 'none';\n    });\n\n    // Save button action\n    saveButton.addEventListener('click', () => {\n      // Add any remaining text in the input as a tag before saving\n      const remainingText = tagsInput.value.trim();\n      if (remainingText) {\n        addTag(remainingText);\n        tagsInput.value = '';\n      }\n      this.handleSaveBookmark(tweetData, currentTags, saveButton);\n    });\n\n    // Note: Enter key handling is now done at dialog level to avoid conflicts\n\n    actionsContainer.appendChild(cancelButton);\n    actionsContainer.appendChild(saveButton);\n\n    // Assemble dialog\n    dialog.appendChild(header);\n    dialog.appendChild(preview);\n    dialog.appendChild(tagsSection);\n    dialog.appendChild(actionsContainer);\n\n    // Add hover behavior to control auto-fade\n    dialog.addEventListener('mouseenter', () => {\n      console.log('🖱️ Mouse entered dialog, stopping auto-fade');\n      this.clearTooltipTimeout();\n    });\n\n    dialog.addEventListener('mouseleave', () => {\n      console.log('🖱️ Mouse left dialog, restarting auto-fade');\n      this.resetTooltipTimeout();\n    });\n\n    // Add outside click dismissal\n    setTimeout(() => {\n      const handleOutsideClick = (e) => {\n        if (!dialog.contains(e.target)) {\n          console.log('🖱️ Outside click detected, closing dialog');\n          this.removeTooltip();\n          document.removeEventListener('click', handleOutsideClick);\n        }\n      };\n      \n      // Add the listener after a small delay to prevent immediate closure\n      document.addEventListener('click', handleOutsideClick);\n      \n      // Store reference for cleanup\n      dialog._outsideClickHandler = handleOutsideClick;\n    }, 100);\n\n    // Add escape key dismissal and enter key save\n    const handleDialogKeys = (e) => {\n      if (e.key === 'Escape') {\n        console.log('⌨️ Escape key pressed, closing dialog');\n        this.removeTooltip();\n        document.removeEventListener('keydown', handleDialogKeys);\n      } else if (e.key === 'Enter') {\n        // Only save on Enter if input is not focused (to avoid interference with tag creation)\n        const activeElement = document.activeElement;\n        const isInputFocused = activeElement && activeElement.classList.contains('xsaved-tag-input');\n        \n        if (!isInputFocused) {\n          console.log('⌨️ Enter key pressed, saving bookmark');\n          // Add any remaining text in the input as a tag before saving\n          const remainingText = tagsInput.value.trim();\n          if (remainingText) {\n            addTag(remainingText);\n            tagsInput.value = '';\n          }\n          this.handleSaveBookmark(tweetData, currentTags, saveButton);\n        }\n      }\n    };\n    \n    document.addEventListener('keydown', handleDialogKeys);\n    dialog._keyHandler = handleDialogKeys;\n\n    return dialog;\n  }\n\n  // AUTO-SAVE: Save bookmark immediately without user interaction\n  autoSaveBookmark(tweetData) {\n    console.log('💾 Auto-saving bookmark to IndexedDB:', { id: tweetData.id, text: tweetData.text?.substring(0, 50) });\n    \n    // Create bookmark entity with empty tags (user can add tags later via modal)\n    const bookmarkEntity = {\n      ...tweetData,\n      tags: [] // Default to empty tags for auto-save\n    };\n\n    // Send to service worker for immediate IndexedDB storage\n    safeRuntimeMessage({\n      action: 'saveBookmark',\n      bookmark: bookmarkEntity\n    }, (response) => {\n      if (response?.success) {\n        console.log('✅ Bookmark auto-saved successfully to IndexedDB');\n        // Update stats silently\n        this.updateStats();\n      } else {\n        console.error('❌ Auto-save failed:', response?.error || 'Unknown error');\n        // Don't show error to user for auto-save failures - they can still use the modal\n      }\n    });\n  }\n\n  handleSaveBookmark(tweetData, tags, saveButton) {\n    \n    // Disable save button during save\n    const originalText = saveButton.textContent;\n    saveButton.textContent = 'Updating...';\n    saveButton.disabled = true;\n    saveButton.style.opacity = '0.7';\n\n    // Create bookmark entity - this will update the existing bookmark with tags\n    const bookmarkEntity = {\n      ...tweetData,\n      tags\n    };\n\n    // Send to service worker (this will update the existing bookmark)\n    safeRuntimeMessage({\n      action: 'saveBookmark',\n      bookmark: bookmarkEntity\n    }, (response) => {\n      if (response?.success) {\n        console.log('✅ Bookmark saved successfully');\n        \n        // Show success state\n        saveButton.textContent = '✓ Updated!';\n        saveButton.style.background = '#00ba7c';\n        \n        // Update stats\n        this.updateStats();\n        \n        // Auto-close after delay\n        setTimeout(() => {\n          this.removeTooltip();\n        }, 1500);\n        \n      } else {\n        // Enhanced error handling with detailed logging\n        let errorMessage = 'Unknown error';\n        let detailedError = 'No response received';\n        \n        if (response === null) {\n          errorMessage = 'Extension unavailable';\n          detailedError = 'Extension context lost (try reloading page)';\n        } else if (response === undefined) {\n          errorMessage = 'No response';\n          detailedError = 'Service worker did not respond';\n        } else if (response.error) {\n          errorMessage = 'Save failed';\n          detailedError = response.error;\n        } else if (response.success === false) {\n          errorMessage = 'Service worker error';\n          detailedError = response.error || response.details || response.message || 'Service worker returned success:false without error details';\n        } else {\n          errorMessage = 'Save failed';\n          detailedError = `Unexpected response: ${JSON.stringify(response)}`;\n        }\n        \n        console.error('❌ Failed to save bookmark:');\n        console.error('  Error message:', errorMessage);\n        console.error('  Detailed error:', detailedError);\n        console.error('  Full response:', response);\n        console.error('  Bookmark data:', bookmarkEntity);\n        \n        // Show error state with tooltip for more details\n        saveButton.textContent = 'Error!';\n        saveButton.style.background = '#f91880';\n        saveButton.title = `${errorMessage}: ${detailedError}`;\n        \n        // Add error details as a temporary tooltip\n        const errorTooltip = document.createElement('div');\n        errorTooltip.style.cssText = `\n          position: absolute;\n          bottom: 100%;\n          left: 50%;\n          transform: translateX(-50%);\n          background: #f91880;\n          color: white;\n          padding: 8px 12px;\n          border-radius: 6px;\n          font-size: 12px;\n          white-space: nowrap;\n          margin-bottom: 8px;\n          z-index: 10001;\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n        `;\n        errorTooltip.textContent = detailedError;\n        \n        saveButton.style.position = 'relative';\n        saveButton.appendChild(errorTooltip);\n        \n        // Reset after delay\n        setTimeout(() => {\n          saveButton.textContent = originalText;\n          saveButton.style.background = '#1DA1F2';\n          saveButton.disabled = false;\n          saveButton.style.opacity = '1';\n          saveButton.title = '';\n          \n          // Remove error tooltip\n          if (errorTooltip.parentNode) {\n            errorTooltip.remove();\n          }\n        }, 4000); // Longer delay to read error message\n      }\n    });\n  }\n\n  positionTooltip(tooltip, event) {\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n    const tooltipRect = { width: 400, height: 300 }; // Estimated\n\n    let left = event.clientX + 15;\n    let top = event.clientY - 10;\n\n    // Adjust horizontal position\n    if (left + tooltipRect.width > viewportWidth - 20) {\n      left = event.clientX - tooltipRect.width - 15;\n    }\n\n    // Adjust vertical position\n    if (top + tooltipRect.height > viewportHeight - 20) {\n      top = event.clientY - tooltipRect.height + 10;\n    }\n\n    // Ensure minimum margins\n    left = Math.max(20, left);\n    top = Math.max(20, top);\n\n    tooltip.style.left = `${left}px`;\n    tooltip.style.top = `${top}px`;\n  }\n\n  removeTooltip() {\n    if (currentTooltip) {\n      // Clean up event listeners\n      if (currentTooltip._outsideClickHandler) {\n        document.removeEventListener('click', currentTooltip._outsideClickHandler);\n      }\n      if (currentTooltip._keyHandler) {\n        document.removeEventListener('keydown', currentTooltip._keyHandler);\n      }\n      \n      // Fade out animation\n      currentTooltip.style.opacity = '0';\n      currentTooltip.style.transform = 'translateY(10px) scale(0.95)';\n      \n      setTimeout(() => {\n        if (currentTooltip && currentTooltip.parentNode) {\n          currentTooltip.parentNode.removeChild(currentTooltip);\n        }\n        currentTooltip = null;\n      }, XSAVED_CONFIG.ui.animationDuration);\n    }\n\n    if (tooltipTimeout) {\n      clearTimeout(tooltipTimeout);\n      tooltipTimeout = null;\n    }\n  }\n\n  clearTooltipTimeout() {\n    if (tooltipTimeout) {\n      clearTimeout(tooltipTimeout);\n      tooltipTimeout = null;\n      console.log('⏰ Cleared auto-fade timeout (user is actively typing)');\n    }\n  }\n\n  resetTooltipTimeout() {\n    if (tooltipTimeout) {\n      clearTimeout(tooltipTimeout);\n      console.log('⏰ Cleared existing timeout');\n    }\n\n    console.log(`⏰ Setting auto-fade timeout for ${XSAVED_CONFIG.ui.fadeTimeout}ms`);\n    tooltipTimeout = setTimeout(() => {\n      console.log('⏰ Auto-fade timeout triggered, closing dialog');\n      this.removeTooltip();\n    }, XSAVED_CONFIG.ui.fadeTimeout);\n  }\n\n  // ===== EXPORT FUNCTIONALITY =====\n  showExportDialog(bookmarks) {\n    console.log('📤 Showing export dialog for', bookmarks.length, 'bookmarks');\n    \n    // Create export dialog overlay\n    const dialogOverlay = document.createElement('div');\n    dialogOverlay.id = 'xsaved-export-dialog';\n    dialogOverlay.style.cssText = `\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      z-index: 20000;\n      background: rgba(0, 0, 0, 0.5);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      padding: 20px;\n    `;\n\n    // Create dialog content\n    const dialogContent = document.createElement('div');\n    dialogContent.style.cssText = `\n      background: #15202b;\n      border-radius: 12px;\n      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);\n      max-width: 600px;\n      width: 100%;\n      max-height: 90vh;\n      overflow-y: auto;\n      color: white;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    `;\n\n    // Generate dialog HTML\n    dialogContent.innerHTML = this.generateExportDialogHTML(bookmarks);\n    \n    dialogOverlay.appendChild(dialogContent);\n    document.body.appendChild(dialogOverlay);\n\n    // Setup event listeners\n    this.setupExportDialogEvents(dialogOverlay, bookmarks);\n  }\n\n  generateExportDialogHTML(bookmarks) {\n    const formats = [\n      { format: 'csv', name: 'CSV Export', description: 'Spreadsheet format for data analysis', icon: '📊' },\n      { format: 'pdf', name: 'PDF Report', description: 'Printable reading list with metadata', icon: '📄' },\n      { format: 'json', name: 'JSON API', description: 'Programmatic access to bookmark data', icon: '🔧' }\n    ];\n\n    const formatsHTML = formats.map(format => `\n      <div class=\"export-format-option\" data-format=\"${format.format}\">\n        <div class=\"format-icon\">${format.icon}</div>\n        <div class=\"format-info\">\n          <div class=\"format-name\">${format.name}</div>\n          <div class=\"format-description\">${format.description}</div>\n        </div>\n        <div class=\"format-radio\">\n          <input type=\"radio\" name=\"export-format\" value=\"${format.format}\" ${format.format === 'csv' ? 'checked' : ''}>\n        </div>\n      </div>\n    `).join('');\n\n    return `\n      <div class=\"export-dialog-header\" style=\"display: flex; justify-content: space-between; align-items: center; padding: 24px 24px 0 24px; border-bottom: 1px solid #38444d; margin-bottom: 20px;\">\n        <h2 style=\"margin: 0; font-size: 24px; font-weight: 700;\">📤 Export Bookmarks</h2>\n        <button class=\"export-dialog-close\" aria-label=\"Close\" style=\"background: none; border: none; font-size: 24px; color: #8899a6; cursor: pointer; padding: 8px; border-radius: 50%;\">×</button>\n      </div>\n      \n      <div class=\"export-dialog-body\" style=\"padding: 0 24px;\">\n        <div class=\"export-summary\" style=\"background: #192734; padding: 16px; border-radius: 8px; margin-bottom: 24px; text-align: center;\">\n          <p style=\"margin: 0; color: #8899a6; font-size: 14px;\">Exporting <strong style=\"color: white;\">${bookmarks.length}</strong> bookmarks</p>\n        </div>\n        \n        <div class=\"export-section\" style=\"margin-bottom: 24px;\">\n          <h3 style=\"margin: 0 0 16px 0; font-size: 18px; font-weight: 600;\">📋 Export Format</h3>\n          <div class=\"export-formats\" style=\"display: flex; flex-direction: column; gap: 12px;\">\n            ${formatsHTML}\n          </div>\n        </div>\n        \n        <div class=\"export-section\" style=\"margin-bottom: 24px;\">\n          <h3 style=\"margin: 0 0 16px 0; font-size: 18px; font-weight: 600;\">🔍 Filters (Optional)</h3>\n          <div class=\"export-filters\" style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 16px;\">\n            <div class=\"filter-group\">\n              <label for=\"export-tags\" style=\"font-size: 14px; font-weight: 500; margin-bottom: 8px; display: block;\">Tags:</label>\n              <input type=\"text\" id=\"export-tags\" placeholder=\"javascript, react, typescript\" style=\"padding: 12px; border: 1px solid #38444d; border-radius: 6px; background: #192734; color: white; font-size: 14px; width: 100%;\">\n            </div>\n            <div class=\"filter-group\">\n              <label for=\"export-author\" style=\"font-size: 14px; font-weight: 500; margin-bottom: 8px; display: block;\">Author:</label>\n              <input type=\"text\" id=\"export-author\" placeholder=\"@username\" style=\"padding: 12px; border: 1px solid #38444d; border-radius: 6px; background: #192734; color: white; font-size: 14px; width: 100%;\">\n            </div>\n            <div class=\"filter-group\">\n              <label for=\"export-date-from\" style=\"font-size: 14px; font-weight: 500; margin-bottom: 8px; display: block;\">Date From:</label>\n              <input type=\"date\" id=\"export-date-from\" style=\"padding: 12px; border: 1px solid #38444d; border-radius: 6px; background: #192734; color: white; font-size: 14px; width: 100%;\">\n            </div>\n            <div class=\"filter-group\">\n              <label for=\"export-date-to\" style=\"font-size: 14px; font-weight: 500; margin-bottom: 8px; display: block;\">Date To:</label>\n              <input type=\"date\" id=\"export-date-to\" style=\"padding: 12px; border: 1px solid #38444d; border-radius: 6px; background: #192734; color: white; font-size: 14px; width: 100%;\">\n            </div>\n          </div>\n        </div>\n        \n        <div class=\"export-section\" style=\"margin-bottom: 24px;\">\n          <h3 style=\"margin: 0 0 16px 0; font-size: 18px; font-weight: 600;\">📝 Options</h3>\n          <div class=\"export-options\" style=\"display: flex; flex-direction: column; gap: 12px;\">\n            <label class=\"option-checkbox\" style=\"display: flex; align-items: center; cursor: pointer; padding: 8px 0;\">\n              <input type=\"checkbox\" id=\"export-include-metadata\" checked style=\"width: 18px; height: 18px; margin-right: 12px;\">\n              <span style=\"font-size: 14px;\">Include metadata and analytics</span>\n            </label>\n            <label class=\"option-checkbox\" style=\"display: flex; align-items: center; cursor: pointer; padding: 8px 0;\">\n              <input type=\"checkbox\" id=\"export-custom-filename\" style=\"width: 18px; height: 18px; margin-right: 12px;\">\n              <span style=\"font-size: 14px;\">Custom filename</span>\n            </label>\n            <div class=\"custom-filename-input\" style=\"margin-left: 30px; margin-top: 8px; display: none;\">\n              <input type=\"text\" id=\"export-filename\" placeholder=\"my-bookmarks\" style=\"width: 100%; padding: 12px; border: 1px solid #38444d; border-radius: 6px; background: #192734; color: white; font-size: 14px;\">\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <div class=\"export-dialog-footer\" style=\"display: flex; justify-content: flex-end; gap: 12px; padding: 24px; border-top: 1px solid #38444d; margin-top: 20px;\">\n        <button class=\"export-btn-cancel\" style=\"padding: 12px 24px; border: 1px solid #38444d; background: #192734; color: white; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer;\">Cancel</button>\n        <button class=\"export-btn-export\" style=\"padding: 12px 24px; border: none; background: #22C55E; color: white; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;\">📤 Export</button>\n      </div>\n    `;\n  }\n\n  setupExportDialogEvents(dialogOverlay, bookmarks) {\n    const dialog = dialogOverlay.querySelector('.export-dialog-content') || dialogOverlay;\n\n    // Close button\n    dialog.querySelector('.export-dialog-close')?.addEventListener('click', () => {\n      this.hideExportDialog();\n    });\n\n    // Cancel button\n    dialog.querySelector('.export-btn-cancel')?.addEventListener('click', () => {\n      this.hideExportDialog();\n    });\n\n    // Export button\n    dialog.querySelector('.export-btn-export')?.addEventListener('click', () => {\n      this.handleExport(bookmarks, dialog);\n    });\n\n    // Format selection\n    dialog.querySelectorAll('.export-format-option').forEach(option => {\n      option.addEventListener('click', (e) => {\n        const radio = option.querySelector('input[type=\"radio\"]');\n        if (radio) {\n          radio.checked = true;\n          \n          // Update visual selection\n          dialog.querySelectorAll('.export-format-option').forEach(opt => {\n            opt.style.borderColor = '#38444d';\n            opt.style.background = '#192734';\n          });\n          option.style.borderColor = '#22C55E';\n          option.style.background = '#1a3a4a';\n        }\n      });\n    });\n\n    // Custom filename toggle\n    const customFilenameCheckbox = dialog.querySelector('#export-custom-filename');\n    const customFilenameInput = dialog.querySelector('.custom-filename-input');\n    \n    customFilenameCheckbox?.addEventListener('change', () => {\n      if (customFilenameCheckbox.checked) {\n        customFilenameInput.style.display = 'block';\n      } else {\n        customFilenameInput.style.display = 'none';\n      }\n    });\n\n    // Outside click to close\n    dialogOverlay.addEventListener('click', (e) => {\n      if (e.target === dialogOverlay) {\n        this.hideExportDialog();\n      }\n    });\n\n    // Escape key to close\n    document.addEventListener('keydown', (e) => {\n      if (e.key === 'Escape') {\n        this.hideExportDialog();\n      }\n    });\n  }\n\n  hideExportDialog() {\n    const dialog = document.getElementById('xsaved-export-dialog');\n    if (dialog) {\n      dialog.remove();\n    }\n  }\n\n  async handleExport(bookmarks, dialog) {\n    const exportButton = dialog.querySelector('.export-btn-export');\n    const originalText = exportButton.textContent;\n    \n    try {\n      // Show initial progress\n      this.showExportProgress(dialog, 'Preparing export...', 10);\n      \n      // Disable button and show loading\n      exportButton.disabled = true;\n      exportButton.textContent = '⏳ Exporting...';\n      \n      // Get export options\n      this.showExportProgress(dialog, 'Validating options...', 20);\n      const options = this.getExportOptions(dialog);\n      \n      // Apply filters if specified\n      this.showExportProgress(dialog, 'Applying filters...', 30);\n      let filteredBookmarks = bookmarks;\n      if (options.filters) {\n        filteredBookmarks = this.applyExportFilters(bookmarks, options.filters);\n      }\n      \n      this.showExportProgress(dialog, `Processing ${filteredBookmarks.length} bookmarks...`, 50);\n      \n      // Send export request to service worker with timeout\n      const exportTimeout = setTimeout(() => {\n        console.error('❌ [CS] Export request timed out after 30 seconds');\n        this.showExportError('Export request timed out. Please try again.');\n        exportButton.disabled = false;\n        exportButton.textContent = originalText;\n      }, 30000); // 30 second timeout\n      \n      safeRuntimeMessage({ \n        action: 'exportBookmarks', \n        bookmarks: filteredBookmarks,\n        options: options\n      }, (response) => {\n        clearTimeout(exportTimeout); // Clear timeout on response\n        \n        // Safely log response without circular references\n        try {\n          const safeResponse = this.sanitizeObject(response);\n          console.log('📤 [CS] Export response received:', {\n            success: safeResponse?.success,\n            hasData: !!safeResponse?.data,\n            filename: safeResponse?.filename,\n            error: safeResponse?.error,\n            hasDetails: !!safeResponse?.details\n          });\n        } catch (logError) {\n          console.log('📤 [CS] Export response received (logging failed)');\n        }\n        \n        if (response?.success) {\n          this.showExportProgress(dialog, 'Preparing download...', 80);\n          \n          // Download the file\n          this.downloadExportedFile(response.data, response.filename);\n          \n          this.showExportProgress(dialog, 'Download completed!', 100);\n          \n          // Show success message\n          this.showExportSuccess(response);\n          \n          // Close dialog after a delay\n          setTimeout(() => {\n            this.hideExportDialog();\n          }, 2000);\n        } else {\n          // Safely extract error information\n          const errorMessage = this.safeExtractError(response);\n          throw new Error(errorMessage);\n        }\n      });\n      \n    } catch (error) {\n      console.error('Export failed:', error);\n      \n      // Ultra-safe error message extraction\n      let errorMessage = 'Export failed';\n      try {\n        // Try to extract error message safely\n        if (error) {\n          if (typeof error === 'string') {\n            errorMessage = error;\n          } else if (typeof error === 'object' && error !== null) {\n            if (typeof error.message === 'string') {\n              errorMessage = error.message;\n            } else if (typeof error.toString === 'function') {\n              const errorString = error.toString();\n              if (errorString !== '[object Object]') {\n                errorMessage = errorString;\n              }\n            }\n          }\n        }\n      } catch (messageError) {\n        console.error('Error processing error message:', messageError);\n        errorMessage = 'Export failed (error details unavailable)';\n      }\n      \n      // Ensure error message is not too long or problematic\n      if (errorMessage.length > 500) {\n        errorMessage = errorMessage.substring(0, 500) + '...';\n      }\n      \n      // Remove any problematic characters\n      errorMessage = errorMessage.replace(/[\\u0000-\\u001F\\u007F-\\u009F]/g, '');\n      \n      this.showExportError(errorMessage);\n    } finally {\n      // Restore button\n      exportButton.disabled = false;\n      exportButton.textContent = originalText;\n    }\n  }\n\n  getExportOptions(dialog) {\n    const format = dialog.querySelector('input[name=\"export-format\"]:checked')?.value || 'csv';\n    const includeMetadata = dialog.querySelector('#export-include-metadata')?.checked || false;\n    const customFilename = dialog.querySelector('#export-custom-filename')?.checked || false;\n    const filename = customFilename ? dialog.querySelector('#export-filename')?.value : undefined;\n    \n    const filters = {};\n    \n    // Get filter values\n    const tagsInput = dialog.querySelector('#export-tags');\n    if (tagsInput?.value) {\n      filters.tags = tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);\n    }\n    \n    const authorInput = dialog.querySelector('#export-author');\n    if (authorInput?.value) {\n      filters.author = authorInput.value.trim();\n    }\n    \n    const dateFromInput = dialog.querySelector('#export-date-from');\n    if (dateFromInput?.value) {\n      filters.dateFrom = dateFromInput.value;\n    }\n    \n    const dateToInput = dialog.querySelector('#export-date-to');\n    if (dateToInput?.value) {\n      filters.dateTo = dateToInput.value;\n    }\n    \n    return {\n      format,\n      filters: Object.keys(filters).length > 0 ? filters : undefined,\n      includeMetadata,\n      filename: filename ? `${filename}.${format}` : undefined\n    };\n  }\n\n  applyExportFilters(bookmarks, filters) {\n    return bookmarks.filter(bookmark => {\n      // Tag filter\n      if (filters.tags?.length) {\n        const bookmarkTags = bookmark.tags || [];\n        const hasMatchingTag = filters.tags.some(tag => \n          bookmarkTags.includes(tag)\n        );\n        if (!hasMatchingTag) return false;\n      }\n      \n      // Author filter\n      if (filters.author) {\n        if (!bookmark.author.toLowerCase().includes(filters.author.toLowerCase())) {\n          return false;\n        }\n      }\n      \n      // Date range filter\n      if (filters.dateFrom || filters.dateTo) {\n        const bookmarkDate = new Date(bookmark.created_at);\n        \n        if (filters.dateFrom) {\n          const fromDate = new Date(filters.dateFrom);\n          if (bookmarkDate < fromDate) return false;\n        }\n        \n        if (filters.dateTo) {\n          const toDate = new Date(filters.dateTo);\n          if (bookmarkDate > toDate) return false;\n        }\n      }\n      \n      return true;\n    });\n  }\n\n  downloadExportedFile(data, filename) {\n    try {\n      console.log('📥 [CS] Starting file download:', filename);\n      \n      // Convert base64 to blob if needed\n      let blob;\n      if (typeof data === 'string') {\n        // Assume it's base64 encoded\n        const byteCharacters = atob(data);\n        const byteNumbers = new Array(byteCharacters.length);\n        for (let i = 0; i < byteCharacters.length; i++) {\n          byteNumbers[i] = byteCharacters.charCodeAt(i);\n        }\n        const byteArray = new Uint8Array(byteNumbers);\n        blob = new Blob([byteArray]);\n      } else {\n        blob = new Blob([data]);\n      }\n      \n      console.log('📥 [CS] Blob created, size:', blob.size, 'bytes');\n      \n      // Use Chrome downloads API for better reliability\n      if (chrome.downloads && chrome.downloads.download) {\n        const url = URL.createObjectURL(blob);\n        chrome.downloads.download({\n          url: url,\n          filename: filename,\n          saveAs: false\n        }, (downloadId) => {\n          if (chrome.runtime.lastError) {\n            console.error('❌ [CS] Chrome download failed:', chrome.runtime.lastError);\n            // Fallback to manual download\n            this.manualDownload(blob, filename);\n          } else {\n            console.log('✅ [CS] Chrome download started, ID:', downloadId);\n            // Clean up the blob URL after a delay\n            setTimeout(() => URL.revokeObjectURL(url), 1000);\n          }\n        });\n      } else {\n        // Fallback to manual download\n        this.manualDownload(blob, filename);\n      }\n    } catch (error) {\n      console.error('❌ [CS] Download failed:', error);\n      throw error;\n    }\n  }\n\n  manualDownload(blob, filename) {\n    console.log('📥 [CS] Using manual download fallback');\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = filename;\n    link.style.display = 'none';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    \n    // Clean up the blob URL after a delay\n    setTimeout(() => URL.revokeObjectURL(url), 1000);\n    console.log('✅ [CS] Manual download completed');\n  }\n\n  showExportSuccess(result) {\n    // Create a success notification\n    const successNotification = document.createElement('div');\n    successNotification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #15202b;\n      border: 2px solid #22C55E;\n      border-radius: 12px;\n      padding: 20px;\n      z-index: 20001;\n      min-width: 300px;\n      max-width: 400px;\n      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);\n      animation: slideInRight 0.3s ease-out;\n    `;\n    \n    // Add CSS animation\n    const style = document.createElement('style');\n    style.textContent = `\n      @keyframes slideInRight {\n        from { transform: translateX(100%); opacity: 0; }\n        to { transform: translateX(0); opacity: 1; }\n      }\n    `;\n    document.head.appendChild(style);\n    \n    successNotification.innerHTML = `\n      <div style=\"display: flex; align-items: center; margin-bottom: 12px;\">\n        <div style=\"font-size: 24px; margin-right: 12px;\">✅</div>\n        <h3 style=\"color: white; margin: 0; font-size: 16px;\">Export Successful!</h3>\n      </div>\n      <div style=\"color: #8899a6; font-size: 14px; line-height: 1.4;\">\n        <p style=\"margin: 0 0 8px 0;\"><strong>File:</strong> ${result.filename}</p>\n        <p style=\"margin: 0 0 8px 0;\"><strong>Size:</strong> ${this.formatFileSize(result.size || 0)}</p>\n        <p style=\"margin: 0 0 8px 0;\"><strong>Bookmarks:</strong> ${result.metadata?.totalBookmarks || 0}</p>\n        <p style=\"margin: 0; color: #22C55E; font-size: 12px;\">File downloaded to your default downloads folder</p>\n      </div>\n    `;\n    \n    document.body.appendChild(successNotification);\n    \n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      if (successNotification.parentNode) {\n        successNotification.style.animation = 'slideInRight 0.3s ease-out reverse';\n        setTimeout(() => {\n          if (successNotification.parentNode) {\n            successNotification.remove();\n          }\n        }, 300);\n      }\n    }, 5000);\n    \n    // Also remove style tag\n    setTimeout(() => {\n      if (style.parentNode) {\n        style.remove();\n      }\n    }, 6000);\n  }\n\n  showExportProgress(dialog, message, percentage) {\n    // Create or update progress indicator\n    let progressContainer = dialog.querySelector('.export-progress');\n    \n    if (!progressContainer) {\n      progressContainer = document.createElement('div');\n      progressContainer.className = 'export-progress';\n      progressContainer.style.cssText = `\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        background: #15202b;\n        border: 2px solid #22C55E;\n        border-radius: 12px;\n        padding: 24px;\n        z-index: 20001;\n        min-width: 300px;\n        text-align: center;\n        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);\n      `;\n      \n      const progressBar = document.createElement('div');\n      progressBar.className = 'progress-bar';\n      progressBar.style.cssText = `\n        width: 100%;\n        height: 8px;\n        background: #38444d;\n        border-radius: 4px;\n        margin: 16px 0;\n        overflow: hidden;\n      `;\n      \n      const progressFill = document.createElement('div');\n      progressFill.className = 'progress-fill';\n      progressFill.style.cssText = `\n        height: 100%;\n        background: linear-gradient(90deg, #22C55E, #16A34A);\n        border-radius: 4px;\n        transition: width 0.3s ease;\n        width: 0%;\n      `;\n      \n      progressBar.appendChild(progressFill);\n      progressContainer.appendChild(progressBar);\n      \n      dialog.appendChild(progressContainer);\n    }\n    \n    // Update progress\n    const progressFill = progressContainer.querySelector('.progress-fill');\n    const progressText = progressContainer.querySelector('.progress-text');\n    \n    if (progressFill) {\n      progressFill.style.width = `${percentage}%`;\n    }\n    \n    if (!progressText) {\n      const text = document.createElement('div');\n      text.className = 'progress-text';\n      text.style.cssText = `\n        color: white;\n        font-size: 16px;\n        font-weight: 500;\n        margin-bottom: 8px;\n      `;\n      progressContainer.insertBefore(text, progressContainer.firstChild);\n    }\n    \n    const text = progressContainer.querySelector('.progress-text');\n    if (text) {\n      text.textContent = message;\n    }\n    \n    // Add percentage\n    const percentageText = progressContainer.querySelector('.progress-percentage');\n    if (!percentageText) {\n      const percent = document.createElement('div');\n      percent.className = 'progress-percentage';\n      percent.style.cssText = `\n        color: #22C55E;\n        font-size: 14px;\n        font-weight: 600;\n        margin-top: 8px;\n      `;\n      progressContainer.appendChild(percent);\n    }\n    \n    const percent = progressContainer.querySelector('.progress-percentage');\n    if (percent) {\n      percent.textContent = `${percentage}%`;\n    }\n  }\n\n  hideExportProgress(dialog) {\n    const progressContainer = dialog.querySelector('.export-progress');\n    if (progressContainer) {\n      progressContainer.remove();\n    }\n  }\n\n  showExportError(error) {\n    // Create a more user-friendly error display\n    const errorDialog = document.createElement('div');\n    errorDialog.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      background: #15202b;\n      border: 2px solid #EF4444;\n      border-radius: 12px;\n      padding: 24px;\n      z-index: 20001;\n      min-width: 400px;\n      max-width: 500px;\n      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);\n    `;\n    \n    errorDialog.innerHTML = `\n      <div style=\"text-align: center; margin-bottom: 16px;\">\n        <div style=\"font-size: 48px; margin-bottom: 8px;\">❌</div>\n        <h3 style=\"color: white; margin: 0 0 8px 0; font-size: 18px;\">Export Failed</h3>\n        <p style=\"color: #8899a6; margin: 0; font-size: 14px;\">${error}</p>\n      </div>\n      <div style=\"background: #1a3a4a; padding: 12px; border-radius: 8px; margin: 16px 0;\">\n        <p style=\"color: #22C55E; margin: 0; font-size: 12px; font-weight: 600;\">Troubleshooting Tips:</p>\n        <ul style=\"color: #8899a6; margin: 8px 0 0 0; padding-left: 20px; font-size: 12px;\">\n          <li>Try exporting fewer bookmarks</li>\n          <li>Check your internet connection</li>\n          <li>Try a different export format</li>\n          <li>Refresh the page and try again</li>\n        </ul>\n      </div>\n      <div style=\"text-align: center;\">\n        <button class=\"error-close-btn\" style=\"\n          background: #EF4444;\n          color: white;\n          border: none;\n          padding: 12px 24px;\n          border-radius: 6px;\n          font-size: 14px;\n          font-weight: 600;\n          cursor: pointer;\n        \">Close</button>\n      </div>\n    `;\n    \n    document.body.appendChild(errorDialog);\n    \n    // Add close functionality\n    errorDialog.querySelector('.error-close-btn').addEventListener('click', () => {\n      errorDialog.remove();\n    });\n    \n    // Auto-close after 10 seconds\n    setTimeout(() => {\n      if (errorDialog.parentNode) {\n        errorDialog.remove();\n      }\n    }, 10000);\n  }\n\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  // Safe object sanitization to prevent circular references\n  sanitizeObject(obj, maxDepth = 3, currentDepth = 0) {\n    if (currentDepth >= maxDepth) return '[Max Depth Reached]';\n    if (obj === null || obj === undefined) return obj;\n    if (typeof obj !== 'object') return obj;\n    \n    try {\n      const seen = new WeakSet();\n      return JSON.parse(JSON.stringify(obj, (key, value) => {\n        if (typeof value === 'object' && value !== null) {\n          if (seen.has(value)) {\n            return '[Circular Reference]';\n          }\n          seen.add(value);\n        }\n        return value;\n      }));\n    } catch (error) {\n      return '[Object could not be sanitized]';\n    }\n  }\n\n  // Safe error extraction to prevent recursion\n  safeExtractError(response) {\n    try {\n      let errorMessage = 'Export failed';\n      \n      // Safely extract error message\n      if (response && typeof response === 'object') {\n        if (typeof response.error === 'string') {\n          errorMessage = response.error;\n        } else if (response.error && typeof response.error.message === 'string') {\n          errorMessage = response.error.message;\n        }\n      }\n      \n      // Safely add details if available\n      if (response && response.details) {\n        try {\n          const details = this.sanitizeObject(response.details, 2);\n          if (details && typeof details === 'object') {\n            const detailsString = JSON.stringify(details, null, 2);\n            errorMessage += `\\n\\nDetails: ${detailsString}`;\n          }\n        } catch (detailsError) {\n          errorMessage += '\\n\\nDetails: [Error details could not be displayed]';\n        }\n      }\n      \n      return errorMessage;\n    } catch (extractError) {\n      return 'Export failed (error details unavailable)';\n    }\n  }\n\n  // ===== NAVIGATION HANDLING =====\n  setupNavigationListener() {\n    // Listen for URL changes (SPA navigation)\n    let currentUrl = window.location.href;\n    \n    const urlObserver = new MutationObserver(() => {\n      if (window.location.href !== currentUrl) {\n        const wasOnBookmarksPage = currentUrl.includes('/i/bookmarks');\n        currentUrl = window.location.href;\n        console.log('🧭 URL changed to:', currentUrl);\n        \n        // If we were on bookmarks page and navigated away, clean up grid state\n        if (wasOnBookmarksPage && !XSAVED_CONFIG.pages.isBookmarksPage()) {\n          console.log('🚪 Navigated away from bookmarks page, cleaning up grid state...');\n          this.hideGridInterface();\n          isGridModeActive = false;\n          console.log('🧹 Grid state reset on navigation away from bookmarks');\n        }\n        \n        // Clean up existing toggle on navigation\n        const existingToggle = document.getElementById('xsaved-bookmarks-toggle');\n        if (existingToggle) {\n          existingToggle.remove();\n          console.log('🧹 Cleaned up existing toggle on navigation');\n        }\n        \n        // Re-initialize based on new page\n        setTimeout(() => {\n          if (XSAVED_CONFIG.pages.isBookmarksPage()) {\n            console.log('📍 Navigated to bookmarks page, initializing...');\n            this.initializeBookmarksPage();\n          }\n        }, 1000); // Increased delay for SPA navigation\n      }\n    });\n\n    urlObserver.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n\n    // Also listen for popstate events\n    window.addEventListener('popstate', () => {\n      const wasOnBookmarksPage = window.location.href.includes('/i/bookmarks');\n      setTimeout(() => {\n        if (XSAVED_CONFIG.pages.isBookmarksPage()) {\n          console.log('📍 Popstate to bookmarks page, initializing...');\n          this.initializeBookmarksPage();\n        } else if (wasOnBookmarksPage) {\n          console.log('🚪 Popstate away from bookmarks page, cleaning up grid state...');\n          this.hideGridInterface();\n          isGridModeActive = false;\n          console.log('🧹 Grid state reset on popstate away from bookmarks');\n        }\n      }, 1000); // Increased delay for SPA navigation\n    });\n  }\n}\n\n// ===== INITIALIZATION =====\nconst xsavedContentScript = new XSavedContentScript();\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    xsavedContentScript.initialize();\n  });\n} else {\n  xsavedContentScript.initialize();\n}\n\n// Also initialize after delays for dynamic pages and SPA navigation\nsetTimeout(() => {\n  xsavedContentScript.initialize();\n}, 1000);\n\n// Additional initialization for slow-loading SPAs\nsetTimeout(() => {\n  xsavedContentScript.initialize();\n}, 3000);\n\n// Final fallback initialization\nsetTimeout(() => {\n  xsavedContentScript.initialize();\n}, 8000);\n\n// Global cleanup\nwindow.addEventListener('beforeunload', () => {\n  if (bookmarkButtonObserver) {\n    bookmarkButtonObserver.disconnect();\n  }\n  \n  // Cleanup theme subscription\n  if (xsavedContentScript && xsavedContentScript.themeUnsubscribe) {\n    xsavedContentScript.themeUnsubscribe();\n  }\n  \n  // Cleanup theme detector\n  if (window.xsavedThemeDetector) {\n    window.xsavedThemeDetector.destroy();\n  }\n});\n\n// Export for testing\nwindow.xsavedContentScript = xsavedContentScript;\n\nconsole.log('✅ XSaved v2 Enhanced Content Script ready!'); "],"names":[],"sourceRoot":""}